# -*- coding: utf-8 -*-
"""Dotsearch

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vjn6KO9HuGOh8uRQ2ESPgH1lHFLzLtcj
"""

bugb = [[0, 0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 8], [-2, -2, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 6]]
import random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf
bug = np.array(bugb)
print(bug[:,0])
change = 0
nummen = 1
global probability
probability = []
prob = 0
chosen = []
result = []
end = []
total = 1.0
total = (total * 1.02) + 1
def running(Statn):
    learn = True
    total = 0
    pro = 0
    probability = []
    result = []
    end = []
    Stats = (Statn)
    starten = Stats[0]
    y = bug[1, 1] - bug[0, 1]
    x = bug[1, 0] - bug[0, 0]
    dist1 = math.pow(x * x + y * y, .5)
    for i in range (len(Stats)):
      starten = Stats[i]
      total += starten[0]
    for i in range (len(Stats)):
      starten = Stats[i]
      probability.append(starten[0]/(total))
    for i in range (len(probability)):
      pro += probability[i]
    print(pro)
    for c in range(1000):
      prob = random.randint(1,100)
      for i in range(len(probability)):
        starten = Stats[i]
        if prob > 0:
          prob = prob - (probability[i] * 100)
          if prob < 0:
            result.append([starten[1],starten[2],starten[3],starten[4],starten[5],starten[6],starten[7], starten[8], starten[9]])
            end.append(starten[10])
            if (count % 200 == 300):
              print(f"final result : {result[len(result) - 1]}")
              print(f"final end : {end[len(result) - 1]}")
              print(f" starten {starten}")
              print(f" starten angle: {starten[8]}")
              print(f" starten should be: {starten[9]}")
              print(f" starten result: {starten[10]}")
    holden = result
    print(f"result len : {len(result)}")
    multiplication_q = np.asarray(result)
    multiplication_a = np.asarray(end)
    multiplication_q = tf.cast(tf.constant(multiplication_q), dtype=tf.float16)
    multiplication_a = tf.cast(tf.constant(multiplication_a), dtype=tf.float16)
    model = tf.keras.Sequential([
      tf.keras.Input(shape=(9, )),
      tf.keras.layers.Dense(16, activation="relu"),
      tf.keras.layers.Dense(16, activation='relu'),
      tf.keras.layers.Dense(8, activation='relu'),
      tf.keras.layers.Dense(1, activation='sigmoid')
    ])
    if (True or count <= 10):
      history = model.compile(loss='mean_squared_error', optimizer=tf.keras.optimizers.Adam(0.01), metrics=["accuracy"])
      model.fit(multiplication_q, multiplication_a, epochs=8, verbose=0)
    ran = random.randint(0,100)
    pick = 0
    endresult = 0
    chosen1 = model.predict(np.asarray([[bug[0, 3] / 5, bug[0, 5] / 5, bug[0, 7] / 5, bug[0, 9] / 5, bug[0, 11] / 5, bug[0, 13] / 5, bug[0, 15] / 5, 1, 1]]), verbose=None)
    chose1 = chosen1[0] + 0.0001
    chosen2 = model.predict(np.asarray([[bug[0, 3] / 5, bug[0, 5] / 5, bug[0, 7] / 5, bug[0, 9] / 5, bug[0, 11] / 5, bug[0, 13] / 5, bug[0, 15] / 5, 0, 1]]), verbose=None)
    chose2 = chosen2[0] + 0.0001
    chosen3 = model.predict(np.asarray([[bug[0, 3] / 5, bug[0, 5] / 5, bug[0, 7] / 5, bug[0, 9] / 5, bug[0, 11] / 5, bug[0, 13] / 5, bug[0, 15] / 5, -1, 1]]), verbose=None)
    chose3 = chosen3[0] + 0.0001
    chosen4 = model.predict(np.asarray([[bug[0, 3] / 5, bug[0, 5] / 5, bug[0, 7] / 5, bug[0, 9] / 5, bug[0, 11] / 5, bug[0, 13] / 5, bug[0, 15] / 5, 1, 0]]), verbose=None)
    chose4 = chosen4[0]
    chosen5 = model.predict(np.asarray([[bug[0, 3] / 5, bug[0, 5] / 5, bug[0, 7] / 5, bug[0, 9] / 5, bug[0, 11] / 5, bug[0, 13] / 5, bug[0, 15] / 5, 0, 0]]), verbose=None)
    chose5 = chosen5[0]
    chosen6 = model.predict(np.asarray([[bug[0, 3] / 5, bug[0, 5] / 5, bug[0, 7] / 5, bug[0, 9] / 5, bug[0, 11] / 5, bug[0, 13] / 5, bug[0, 15] / 5, -1, 0]]), verbose=None)
    chose6 = chosen6[0]
    pikn1 = [chose1, chose2, chose3, chose4, chose5, chose6]
    print(f"move score:{pikn1[np.argmax([chose1, chose2, chose3])]}, dont move score: {pikn1[np.argmax([chose4, chose5, chose6]) + 3]}")
    picked = np.argmax([chose1, chose2, chose3, chose4, chose5, chose6])
    if (100 < ran):
      picked = random.randint(0,5)
      print(f"OVERIDE")
    if (picked == 0):
      achange = 1
      dchange = 1
      print("1,1")
    elif (picked == 1):
      achange = 0
      dchange = 1
      print("0,1")
    elif (picked == 2):
      achange = -1
      dchange = 1
      print("-1,1")
    elif (picked == 3):
      achange = 1
      dchange = 0
      print("1,0")
    elif (picked == 4):
      achange = 0
      dchange = 0
      print("0,0")
    elif (picked == 5):
      achange = -1
      dchange = 0
      print("-1,0")
    dchange1 = 1
    if (dchange > 0):
      dchange1 = 0
    error = 0
    bug[0, 16] = bug[0, 16] + achange * 2
    bug[0,0] = bug[0,0] + dchange * .3 * math.cos(pi/8 * bug[0, 16])
    bug[0,1] = bug[0,1] + dchange * .3 * math.sin(pi/8 * bug[0, 16])
    y = bug[1, 1] - bug[0, 1]
    x = bug[1, 0] - bug[0, 0]
    dist2 = math.pow(x * x + y * y, .5)
    netgain = sigmoid((dist1 - dist2) * 5)
    if (dchange == 0):
      netgain += 0
    print(f"netgain: {netgain}")
    if (learn):
      Stats.append([total * 0.01 + 1, bug[0, 3] / 5, bug[0, 5] / 5, bug[0, 7] / 5, bug[0, 9] / 5, bug[0, 11] / 5, bug[0, 13] / 5, bug[0, 15] / 5, achange, dchange, netgain])
    return Stats

bugb = [[0, 0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 8], [2, 2, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 6]]
import random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf
bug = np.array(bugb)
print(bug[:,0])
change = 0
nummen = 1
global probability
probability = []
prob = 0
chosen = []
result = []
end = []
count = 0
total = 1.0
holden = 0
total = (total * 1.02) + 1
while (20 > len(feedback)):
  y = bug[1, 1] - bug[0, 1]
  x = bug[1, 0] - bug[0, 0]
  dist3 = x * x + y * y
  if (dist3 < .3):
    feedback.append(["Success", count])
    bug[0, 0] = 0
    bug[0, 1] = 0
    bug[1, 0] = 2 * random.randint(-2,1) + 1
    bug[1, 0] = 2 * random.randint(-2,1) + 1
    count = 0
    print(feedback)
  elif ((dist3 > 25) | (count >= 100)):
    feedback.append(["Failure" , count])
    bug[0, 0] = 0
    bug[0, 1] = 0
    bug[1, 0] = 2 * random.randint(-2,1) + 1
    bug[1, 0] = 2 * random.randint(-2,1) + 1
    count = 0
    print(feedback)
  else:
    location(bug)
    Stats = running(Stats)
    print(Stats[len(Stats) - 1])
    print(f"trail : {len(feedback) + 1}.{count + 1}")
    count += 1
Statd = np.array(Stats)
print(Average(Statd[:, 10]))

#training
bugb = [[0, 0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 8], [2, 2, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 0, 5.0, 6]]
import random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf
bug = np.array(bugb)
print(bug[:,0])
change = 0
nummen = 1
global probability
probability = []
prob = 0
chosen = []
result = []
end = []
count = 0
total = 1.0
holden = 0
total = (total * 1.02) + 1
feedback = []
while (500 > len(feedback)):
  y = bug[1, 1] - bug[0, 1]
  x = bug[1, 0] - bug[0, 0]
  dist3 = x * x + y * y
  feedback.append(["Sucsess", count])
  bug[0, 0] = 0
  bug[0, 1] = 0
  bug[1, 0] = random.randint(1,3)
  bug[1, 1] = random.randint(1,3)
  bug[0, 16] = random.randint(-1,4)
  location(bug)
  Stats = running(Stats)
  print(f"trail : {len(feedback) + 1}.{count + 1}")
  count += 1
  y = bug[1, 1] - bug[0, 1]
  x = bug[1, 0] - bug[0, 0]
  dist3 = x * x + y * y
  feedback.append(["Fail", count])
  bug[0, 0] = 0
  bug[0, 1] = 0
  bug[1, 0] = random.randint(-3,-1)
  bug[1, 1] = random.randint(-3,-1)
  bug[0, 16] = random.randint(-1,4)
  location(bug)
  Stats = running(Stats)
  print(f"trail : {len(feedback) + 1}.{count + 1}")
  count += 1
Statd = np.array(Stats)
print(Average(Statd[:, 10]))

data_stats = pd.DataFrame(Stats)
data_stats.head(60)

total = 0
for i in range (len(Stats)):
  starten = Stats[i]
  total += starten[0]
for i in range(1):
  Stats.append([total * .001 + 1, 1, 1, 1, 1, 1, 1, 1, -1, 0, sigmoid(0)])
  total = (total * 1.001) + 1
  Stats.append([total * .001 + 1, 1, 1, 1, 1, 1, 1, 1, -1, 0, sigmoid(0)])
  total = (total * 1.001) + 1
  Stats.append([total * .001 + 1, 1, 1, 1, 1, 1, 1, 1, -1, 1, sigmoid(-1)])
  total = (total * 1.001) + 1
  Stats.append([total * .001 + 1, .9, .6, .5, .6, .9, 1, 1, -1, 1, sigmoid(1)])
  total = (total * 1.001) + 1
  Stats.append([total * .001 + 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, sigmoid(0)])
  total = (total * 1.001) + 1
  Stats.append([total * .001 + 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, sigmoid(0)])
  total = (total * 1.001) + 1
  Stats.append([total * .001 + 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, sigmoid(-1)])
  total = (total * 1.001) + 1
  Stats.append([total * .001 + 1, 1, .6, .5, .6, 1, 1, 1, 1, 1, sigmoid(1)])
  total = (total * 1.001) + 1

Stats = Stats[200:]

len(Stats)

var1 = 0
for i in range(len(Stats)):
  if (np.array(Stats)[i,9] == 0):
    var1 += 1
var1

np.array(Stats).shape

feedback

feedback = []

Stats = []
total = 0

pas = []
Statn = np.array(Stats)
for i in range(len(Stats) - 200):
    if ((Statn[i + 200, 1] == 5) & (Statn[i + 200, 2] == 5) & (Statn[i + 200, 3] == 5) & (Statn[i + 200, 4] == 5) & (Statn[i + 200, 5] == 5) & (Statn[i + 200, 6] == 5) & (Statn[i + 200, 7] == 5) & (Statn[i + 200, 9] == 0)):
      pas.append(Statn[i,1])
print(len(pas))
print(Statn[200])
total = 0
for i in range(len(Stats)):
  total += Statn[i,0]
total
print(np.argmin(Statn[:, 0]))
Statn[:, 9]
Statn[:, 10]

def Average(lst):
    return sum(lst) / len(lst)
def sigmoid(x):
  return 1 / (1 + math.exp(-x))

import matplotlib.pyplot as plt
import math
from math import pi
def location(bug):
  plt.xlim(-12, 12)
  plt.ylim(-12, 12)
  plt.scatter(bug[1,0], bug[1,1], color='red')
  for i in range(1):
    plt.scatter(bug[i,0], bug[i,1])
    for x in range(7):
      sett = [5]
      for y in range(len(bug)):
        if (i != y):
          sett.append(distance(i, [(1/2*pi + (math.atan((bug[y, 1] - bug[i,1])/(bug[y, 0] - bug[i,0])))), bug[y, 0], bug[y, 1], -2, 2], x - 3))
      guess =  np.argmin(sett)
      bug[i, 2 * x + 3] = sett[guess]
      plt.scatter(bug[i,0] + bug[i, 2 * x + 3] * math.cos((bug[i,16] + x - 3) * pi/8), bug[i,1] + bug[i, 2 * x + 3] * math.sin((bug[i,16] + x - 3) * pi/8), color='blue')
  plt.scatter(bug[1,0], bug[1,1], color='red')
  plt.show()
def lineintsec2(line1, line2):
  distance = 10000
  y1 = line2[2] - line1[2]
  x1 = line2[1] - line1[1]
  r = 10000
  if (math.sin(line1[0]) + line2[0] * math.cos(line1[0]) != 0):
    r = ((line2[0]*x1 + y1) / (math.sin(line1[0]) + line2[0] * math.cos(line1[0])))
  return r
def Average(lst):
    return sum(lst) / len(lst)
def sigmoid(x):
  return 1 / (1 + math.exp(-x))
def lineintsec(line1, line2):
  distance = 10000
  y1 = line2[2] - line1[2]
  x1 = line2[1] - line1[1]
  dis = math.pow(x1 * x1 + y1 * y1, .5)
  ad = (line2[0] - line1[0]) % (2 * pi)
  if (x1 < 0):
    ad += pi
  r = 10000
  fall = ad
  if ((ad != 0)):
    spot = dis * math.sin(1/2 * pi - ad)/ math.sin(ad)
    if((-spot >= line2[3]) & (-spot <= line2[4])):
      r = (dis * math.sin(pi * 1/2) / math.sin(ad))
  return r
def distance(i, line, an):
    slope = math.fabs(math.tan((bug[i,16] + an - 3) * pi/8))
    if (math.sin((bug[i,16] + an - 3) * pi/8) > 0):
      slope = -math.fabs(math.tan((bug[i,16] - an) * pi/8))
    c1d = [lineintsec([((bug[i,16] + an) * pi/8), bug[i,0], bug[i, 1]], line), 5]
    guess = 0
    iso = [5]
    if (c1d[0] > 0):
      guess = np.argmin(c1d)
      iso = [c1d[guess], 5]
      guess = np.argmin(iso)
    return iso[guess]

def lineintsec2(line1, line2):
  distance = 10000
  y1 = line2[2] - line1[2]
  x1 = line2[1] - line1[1]
  r = 10000
  if (math.sin(line1[0]) + line2[0] * math.cos(line1[0]) != 0):
    r = ((line2[0]*x1 + y1) / (math.sin(line1[0]) + line2[0] * math.cos(line1[0])))
  return r

def lineintsec(line1, line2):
  distance = 10000
  y1 = line2[2] - line1[2]
  x1 = line2[1] - line1[1]
  dis = math.pow(x1 * x1 + y1 * y1, .5)
  ad = (line2[0] - line1[0]) % (2 * pi)
  if (x1 < 0):
    ad += pi
  r = 10000
  fall = ad
  if ((ad != 0)):
    spot = dis * math.sin(1/2 * pi - ad)/ math.sin(ad)
    if((-spot >= line2[3]) & (-spot <= line2[4])):
      r = (dis * math.sin(pi * 1/2) / math.sin(ad))
  return r

print(lineintsec([pi* 1/4, 0, 0], [pi*3/4, 2, 2, -100000, 1000000]))

def distance(i, line, an):
    slope = math.fabs(math.tan((bug[i,16] + an - 3) * pi/8))
    if (math.sin((bug[i,16] + an - 3) * pi/8) > 0):
      slope = -math.fabs(math.tan((bug[i,16] - an) * pi/8))
    c1d = [lineintsec([((bug[i,16] + an) * pi/8), bug[i,0], bug[i, 1]], line), 5]
    guess = 0
    iso = [5]
    if (c1d[0] > 0):
      guess = np.argmin(c1d)
      iso = [c1d[guess], 5]
      guess = np.argmin(iso)
    return iso[guess]

dog = 4
type(total)