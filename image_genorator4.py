# -*- coding: utf-8 -*-
"""Image Genorator4

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L6Au1gtbvEqpeTWRyTDYFoyv_ApcpJDD
"""

import numpy as np
import tensorflow as tf
import keras
import math
import matplotlib.pyplot as plt
from keras import layers
import random
from sklearn.utils import shuffle
import copy



IMAGE_SIZEX = 10
IMAGE_SIZEY = 10

import os

def create_model_checkpoint(model_name, save_path="model_experiments"):
  return tf.keras.callbacks.ModelCheckpoint(filepath=os.path.join(save_path, model_name), # create filepath to save model
                                            verbose=0, # only output a limited amount of text
                                            save_best_only=True)

def pathogorean(a, b):
  return math.sqrt(math.pow(a, 2)+math.pow(b, 2))
def sigmoid(x):
  return 1 / (1 + math.exp(-x))

"""def makeShape2(location, size, shape, image_sizex=IMAGE_SIZEX, image_sizey=IMAGE_SIZEY, shapes=["square", "circle" "rectangle"]):
  Image = []
  noise1 = math.pow(random.randint(1, 10), 2)
  blob = []
  Image_type = []
  length = random.randint(8, (image_sizex)-2)
  width = random.randint(8, (image_sizex)-2)
  semislope = random.randint(-4,4)
  topbot = random.randint(0, 1)
  for y in range(image_sizey):
     holder = []
     for x in range(image_sizex):
        if (shape == "square"):
          Image_type = [1, 0, 0, 0, 0, 0]
          if (((location[0] - size/2 <= x) & (location[0] + size/2 > x) & (location[1]-size/2 <= y) & (location[1] + size/2 > y))):
            holder.append(1)
          else:
            holder.append(0)
        elif(shape == "circle"):
          Image_type = [0, 1, 0, 0, 0, 0]
          distance = pathogorean(location[0] - x, location[1] - y)
          if (distance < (size + .5)/2):
            holder.append(1)
          else:
            holder.append(0)
        elif(shape == "blob"):
          Image_type = [0, 0, 0, 1, 0,  0]
          holder.append(0)
        elif(shape == "rectangle"):
          Image_type = [0, 0, 0, 0, 1,  0]
          if (3 > width - length & 0 <= width - length):
            width += 3 - (width - length)
          elif(3 > length - width & 0 <= length - width):
            length += 3 - (length - width)
          if (((location[0] - width/2 <= x) & (location[0] + width/2 > x) & (location[1]-length/2 <= y) & (location[1] + length/2 > y))):
            holder.append(1)
          else:
            holder.append(0)
        elif(shape == "semi-circle"):
          Image_type = [0, 0, 0, 0, 0, 1]
          distance = pathogorean(location[0] - x, location[1] - y)
          if (((distance < (size + .5)/2) and topbot == 0) and (y - location[1] <= (math.pow(semislope, 2) * (x - location[0])/4))):
            holder.append(1)
          elif(((distance < (size + .5)/2) and topbot == 1) and (y - location[1] >= (math.pow(semislope, 2) * (x - location[0])/4))):
            holder.append(1)
          else:
            holder.append(0)
     Image.append(holder)
  if(shape == "blob"):
    while(len(blob) < random.randint(2, 5)):
      blob.append([random.randint(0, image_sizey-1), random.randint(0, image_sizex-1), random.randint(4, (image_sizex-2)), random.randint(0,len(shapes) - 1), math.pow(random.randint(0 , 50), 2), random.randint(0 , 2)])
    length = random.randint(8, (image_sizex)-2)
    width = random.randint(8, (image_sizex)-2)
    for y in range(image_sizey):
      for x in range(image_sizex):
        for b in range(len(blob)):
          if (shapes[blob[b][3]] == "square"):
            Image_type[0] = 0
            if (((blob[b][0] - blob[b][2]/2 <= x) & (blob[b][0] + blob[b][2]/2 > x) & (blob[b][1]-blob[b][2]/2 <= y) & (blob[b][1] + blob[b][2]/2 > y))):
              if(blob[b][4] == 0):
                Image[y][x] = 0
              else:
                Image[y][x] = 1
          elif(shapes[blob[b][3]] == "circle"):
            Image_type[1] = 0
            distance = pathogorean(blob[b][0] - x, blob[b][1] - y)
            if (distance < (blob[b][2] + .5)/2):
              if(blob[b][4] == 0):
                Image[y][x] = 0
              else:
                Image[y][x] = 1
          elif(shapes[blob[b][3]] == "rectangle"):
            if (3 > width - length & 0 <= width - length):
              width += 3 - (width - length)
            elif(3 > length - width & 0 <= length - width):
              length += 3 - (length - width)
            if (((blob[b][0] - width/2 <= x) & (blob[b][0] + width/2 > x) & (blob[b][1]-length/2 <= y) & (blob[b][1] + length/2 > y))):
              if(blob[b][4] == 0):
                Image[y][x] = 0
              else:
                Image[y][x] = 1
  total = 0
  if (random.randint(0, 9) == 0):
    staticlevel = math.pow(random.randint(0, 40), 2);
    for y in range(image_sizey):
      for x in range(image_sizex):
        if (random.randint(0, 1550) < staticlevel):
          Image[y][x] = 1
        for i in range(len(Image_type)):
          Image_type[i] = Image_type[i] - math.sqrt(staticlevel)*Image_type[i]/40
  if (random.randint(0, 9) == 0):
    staticlevel = math.pow(random.randint(0, 40), 2);
    for y in range(image_sizey):
      for x in range(image_sizex):
        if (random.randint(0, 1550) < staticlevel):
          Image[y][x] = 0
    for i in range(len(Image_type)):
      Image_type[i] = Image_type[i] - math.sqrt(staticlevel)*Image_type[i]/40
  if (random.randint(0, 15) == 0):
    staticlevel = math.pow(random.randint(5, 20), 2);
    for y in range(image_sizey):
      cuttoff = random.randint(0, image_sizex)
      if (random.randint(0, 360) < staticlevel):
        cutwidth = random.randint(1, 3)
        for x in range(image_sizex - (random.randint(0, image_sizex) + cuttoff)):
          if (x > cuttoff):
            for c in range(cutwidth):
               if (c+x < image_sizex):
                if (c+y < image_sizey):
                  Image[y+c][x] = 1
    for i in range(len(Image_type)):
      Image_type[i] = Image_type[i] - math.sqrt(staticlevel)*Image_type[i]/60
  if (random.randint(0, 15) == 0):
    staticlevel = math.pow(random.randint(5, 20), 2);
    for x in range(image_sizex):
      cuttoff = random.randint(0, image_sizey)
      if (random.randint(0, 360) < staticlevel):
        cutwidth = random.randint(1, 3)
        for y in range(image_sizey - (random.randint(0, image_sizey) + cuttoff)):
          if (y > cuttoff):
            for c in range(cutwidth):
               if (c+x < image_sizex):
                Image[y][c+x] = 0
    for i in range(len(Image_type)):
      Image_type[i] = Image_type[i] - math.sqrt(staticlevel)*Image_type[i]/60
  if (random.randint(0, 15) == 0):
    staticlevel = math.pow(random.randint(5, 20), 2);
    for y in range(image_sizey):
      cuttoff = random.randint(0, image_sizex)
      if (random.randint(0, 360) < staticlevel):
        cutwidth = random.randint(1, 3)
        for x in range(image_sizex - (random.randint(0, image_sizex) + cuttoff)):
          if (x > cuttoff):
            for c in range(cutwidth):
              if (c+y < image_sizey):
                Image[y+c][x] = 1
    for i in range(len(Image_type)):
      Image_type[i] = Image_type[i] - math.sqrt(staticlevel)*Image_type[i]/60
  if (random.randint(0, 15) == 0):
    staticlevel = math.pow(random.randint(5, 20), 2);
    for x in range(image_sizex):
      cuttoff = random.randint(0, image_sizey)
      if (random.randint(0, 360) < staticlevel):
        cutwidth = random.randint(1, 3)
        for y in range(image_sizey - (random.randint(0, image_sizey) + cuttoff)):
          if (y > cuttoff):
            for c in range(cutwidth):
              if (c+x < image_sizex):
                Image[y][c+x] = 0
    for i in range(len(Image_type)):
      Image_type[i] = Image_type[i] - math.sqrt(staticlevel)*Image_type[i]/60
  if (random.randint(0, 9) == 0):
    staticlevel = math.pow(random.randint(0, 40), 2);
    for y in range(image_sizey):
      for x in range(image_sizex):
        if (random.randint(0, 1550) < staticlevel):
          Image[y][x] = 1
        for i in range(len(Image_type)):
          Image_type[i] = Image_type[i] - math.sqrt(staticlevel)*Image_type[i]/40
  if (random.randint(0, 9) == 0):
    staticlevel = math.pow(random.randint(0, 40), 2);
    for y in range(image_sizey):
      for x in range(image_sizex):
        if (random.randint(0, 1550) < staticlevel):
          Image[y][x] = 0
    for i in range(len(Image_type)):
      Image_type[i] = Image_type[i] - math.sqrt(staticlevel)*Image_type[i]/40
  for i in range(len(Image_type)):
    total += Image_type[i]
  Image_type[2] = 1 - total
  return Image, Image_type
"""

def makeShapeNoStatic(location, size, shape, image_sizex=IMAGE_SIZEX, image_sizey=IMAGE_SIZEY, shapes=["square", "circle" "rectangle"]):
  Image = []
  noise1 = math.pow(random.randint(1, 10), 2)
  blob = []
  Image_type = []
  length = random.randint(8, (image_sizex)-2)
  width = random.randint(8, (image_sizex)-2)
  semislope = random.randint(-4,4)
  topbot = random.randint(0, 1)
  for y in range(image_sizey):
     holder = []
     for x in range(image_sizex):
        if (shape == "square"):
          Image_type = [1, 0, 0, 0, 0, 0]
          if (((location[0] - size/2 <= x) & (location[0] + size/2 > x) & (location[1]-size/2 <= y) & (location[1] + size/2 > y))):
            holder.append(1)
          else:
            holder.append(0)
        elif(shape == "circle"):
          Image_type = [0, 1, 0, 0, 0, 0]
          distance = pathogorean(location[0] - x, location[1] - y)
          if (distance < (size + .5)/2):
            holder.append(1)
          else:
            holder.append(0)
        elif(shape == "rectangle"):
          Image_type = [0, 0, 0, 1, 0, 0]
          if (3 > width - length & 0 <= width - length):
            width += 3 - (width - length)
          elif(3 > length - width & 0 <= length - width):
            length += 3 - (length - width)
          if (((location[0] - width/2 <= x) & (location[0] + width/2 > x) & (location[1]-length/2 <= y) & (location[1] + length/2 > y))):
            holder.append(1)
          else:
            holder.append(0)
        elif(shape == "semi-circle"):
          Image_type = [0, 0, 0, 0, 1, 0]
          distance = pathogorean(location[0] - x, location[1] - y)
          if (((distance < (size + .5)/2) and topbot == 0) and (y - location[1] <= (math.pow(semislope, 2) * (x - location[0])/4))):
            holder.append(1)
          elif(((distance < (size + .5)/2) and topbot == 1) and (y - location[1] >= (math.pow(semislope, 2) * (x - location[0])/4))):
            holder.append(1)
          else:
            holder.append(0)
     Image.append(holder)
  return Image, Image_type

def shapelist(shapes, total, image_sizex=IMAGE_SIZEX, image_sizey=IMAGE_SIZEY):
  image_holder = []
  category_holder = []
  for i in range(total):
    shapeindex = random.randint(0, len(shapes)-1)
    size = random.randint(4, (image_sizex)-2)
    holder = makeShapeNoStatic([random.randint(int(size/2), int(image_sizex - size/2)), random.randint(int(size/2), int(image_sizey - size/2))], size, shapes[shapeindex])
    image_holder.append(holder[0])
    category_holder.append(holder[1])
  #static_shapes(image_holder, category_holder)
  return image_holder, category_holder

Images, Image_category = shapelist(["circle", "square"], 5000)
val_Images, val_Image_category = shapelist(["circle", "square"], 100)

#displays training data
for i in range(100):
  if (Image_category[i][1] > 0):
    print(Image_category[i])
    plt.imshow(Images[i], interpolation='none')
    plt.show()

model_1 = tf.keras.Sequential([
  tf.keras.layers.Conv2D(filters=15, kernel_size=1, activation="relu", input_shape=(IMAGE_SIZEX, IMAGE_SIZEY, 1)),
  tf.keras.layers.Flatten(),
  tf.keras.layers.Dense(256, activation="relu"),
  tf.keras.layers.Dense(256, activation="relu"),
  tf.keras.layers.Dense(128, activation="relu"),
  tf.keras.layers.Dense(128, activation="relu"),
  tf.keras.layers.Dense(128, activation="relu"),
  tf.keras.layers.Dense(64, activation="relu"),
  tf.keras.layers.Dense(64, activation="relu"),
  tf.keras.layers.Dense(64, activation="relu"),
  tf.keras.layers.Dense(6, activation="softmax")
], name="model_1.keras")
model_1.compile(loss="categorical_crossentropy", #we have binary data
                 optimizer=tf.keras.optimizers.Adam(),
                 metrics=["accuracy"])

history = model_1.fit(x=np.array(Images),
                      y=np.array(Image_category),
                      validation_data=(np.array(val_Images), np.array(val_Image_category)),
                      epochs=10,
                      callbacks=[create_model_checkpoint(model_name=model_1.name)])

model_2 = tf.keras.models.load_model("model_experiments/model_1.keras")

def copy_matrix(matrix):
  matrix_holden = []
  for y in range(len(matrix)):
    matrix_holden.append(matrix[y].copy())
  return matrix_holden

BASE_MATRIX_ORDER = []
for y in range(IMAGE_SIZEY):
  for x in range(IMAGE_SIZEX):
    BASE_MATRIX_ORDER.append(y*IMAGE_SIZEX + x)

def fixup5(Image, shape, model=model_2, shuffle=True):
  Image_Pos = copy_matrix(Image)
  Image_Anti = copy_matrix(Image)
  holderoldstat = model.predict(np.array([Image_Pos]), verbose=0)[0]
  old = holderoldstat[shape]
  statold = holderoldstat[2]
  if (shuffle == True):
    random.shuffle(BASE_MATRIX_ORDER)
  for y in range(len(Image)):
     for x in range(len(Image[0])):
      xh = x
      yh = y
      if(random.randint(0,9) < 10):
        if (Image_Anti[yh][xh] == 0):
          Image_Anti[yh][xh] = 1
        else:
          Image_Anti[yh][xh] = 0
        holdernewstat = model.predict(np.array([Image_Anti]), verbose=0)[0]
        new = holdernewstat[shape]
        statnew = holdernewstat[2]
        if(sigmoid((new-old)/old*500)*100>random.randint(0,99)):
          Image_Pos[yh][xh] = Image_Anti[yh][xh]
          old = new
          statold = statnew
        else:
          Image_Anti[yh][xh] = Image_Pos[yh][xh]
  return Image_Pos, old, statold

Saves_Images = []

def randomImage():
  AI_Image=[]
  for y in range(IMAGE_SIZEY):
    holder = []
    for x in range(IMAGE_SIZEX):
      if((random.randint(0, 99) < 50)):
        holder.append(1)
      else:
        holder.append(0)
    AI_Image.append(holder)
  return AI_Image



Halusinations = []
HalusinationProgress = []
Halusinations_Catagory=[]

def catagoryGradiant(halusin_cat):
  cat_size = len(halusin_cat)
  for i in range(cat_size):
    for shape in range(len(halusin_cat[0])):
      halusin_cat[i][shape]*=(i)/cat_size
    halusin_cat[i][5]=(cat_size-i)/cat_size
  return halusin_cat

#will impove over time running. will learn from mistakes
for iii in range(2000):
  for ii in range(3):
    AI_Image=randomImage()
    score = 0
    while(score<=.95):
      hold = fixup5(AI_Image, 1, model=model_1)
      AI_Image = hold[0]
      print(ii + 1)
      Saves_Images.append(AI_Image)
      score = hold[1]
      if (ii == ii):
        print("Circle: " + str(hold[1]))
        print("Static: " + str(hold[2]))
        print("Circle")
        plt.imshow(AI_Image, interpolation='none')
        plt.show()
    if (random.randint(0, 1) == 0):
            staticlevel = math.pow(random.randint(0, 40), 2);
            for y in range(len(AI_Image)):
              for x in range(len(AI_Image[0])):
                if (random.randint(0, 1550) < staticlevel):
                  if(random.randint(0,1)==0):
                    AI_Image[y][x] = 1
                  else:
                    AI_Image[y][x] = 0
    catagory=[0, 1, 0, 0, 0, 0]
    #static_shapes([AI_Image], [catagory])
    Halusinations.append(AI_Image)
    Halusinations_Catagory.append([0, 1, 0, 0, 0, 0])
    AI_Image=randomImage()
    score = 0
    while(score<=.95):
      hold = fixup5(AI_Image, 0, model=model_1)
      AI_Image = hold[0]
      print(ii + 1)
      Saves_Images.append(AI_Image)
      score = hold[1]
      if (ii == ii):
          print("Square: " + str(hold[1]))
          print("Static: " + str(hold[2]))
          print("Circle")
          plt.imshow(AI_Image, interpolation='none')
          plt.show()
      if (random.randint(0, 1) == 0):
              staticlevel = math.pow(random.randint(0, 40), 2);
              for y in range(len(AI_Image)):
                for x in range(len(AI_Image[0])):
                  if (random.randint(0, 1550) < staticlevel):
                    if(random.randint(0,1)==0):
                      AI_Image[y][x] = 1
                    else:
                      AI_Image[y][x] = 0
      catagory=[1, 0, 0, 0, 0, 0]
      #static_shapes([AI_Image], [catagory])
      Halusinations.append(AI_Image)
      Halusinations_Catagory.append([1, 0, 0, 0, 0, 0])
  HalusinationProgress.append(AI_Image)
  Images, Image_category = shapelist(["circle", "square"], len(Halusinations))
  AllImages=Images+Halusinations
  AllImagesCatagories=Image_category+catagoryGradiant(copy.deepcopy(Halusinations_Catagory))
  print(len(AllImagesCatagories))
  AllImages, AllImagesCatagories = shuffle(AllImages, AllImagesCatagories, random_state=42)
  history = model_1.fit(x=np.array(AllImages),
                      y=np.array(AllImagesCatagories),
                      epochs=10,
                      verbose=1,
                      callbacks=[create_model_checkpoint(model_name=model_1.name)])