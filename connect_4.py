# -*- coding: utf-8 -*-
"""Connect 4

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17C1scV71989qxzQO3IBp3EGORN8QnBqC
"""

import matplotlib.pyplot as plt
import random
import numpy as np
import pandas as pd
import math
import copy
import time
import ast
import csv

class HelperFuncitons:
  def getNumberInbetween(self, list_, start_, end_):
    total=0;
    for i in range(end_-start_):
      total+=list_[i+start_]
    return total
class Neat_AI:
  def __init__(self, input_size_,output_size_,ai_depth_):
    self.helper = HelperFuncitons()
    self.dna = [[[] for i in range(input_size_)]]
    for ind_depth in range(ai_depth_):
      self.dna.append([])
    self.dna.append([0]*output_size_)

  def setNodeStructure(self):
    self.nodeStructure=[]
    for ind_layer in range(len(self.dna)):
      self.nodeStructure.append(len(self.dna[ind_layer]))
  def getNodeStructure(self):
    self.setNodeStructure()
    print(self.nodeStructure)

  def mutateRandomNode(self):
    self.setNodeStructure()
    topNode=random.randint(0, self.helper.getNumberInbetween(self.nodeStructure, 0, len(self.nodeStructure)-1)-1)
    layer_start=0
    row_start=0
    i=0
    while(i<topNode):
      if(row_start+1<self.nodeStructure[layer_start]):
        row_start+=1
      else:
        row_start=0
        layer_start+=1
        if(self.nodeStructure[layer_start]==0):
          i-=1
      i+=1
    bottomNode=random.randint(self.helper.getNumberInbetween(self.nodeStructure, 0, layer_start+1), self.helper.getNumberInbetween(self.nodeStructure, 0, len(self.nodeStructure))-1)
    layer_end=0
    row_end=0
    i=0
    while(i<bottomNode):
      if(row_end+1<self.nodeStructure[layer_end]):
        row_end+=1
      else:
        row_end=0
        layer_end+=1
        if(self.nodeStructure[layer_end]==0):
          i-=1
      i+=1
    self.mutateAdd(layer_start, row_start, layer_end, row_end)

  def mutateAdd(self, layer_start_, row_start_, layer_end_, row_end_):
    self.setNodeStructure()
    if(layer_end_-1!=0):
      self.dna[layer_start_][row_start_].append([self.nodeStructure[layer_start_+1],[1, 0]])
      for layer in range(layer_end_-layer_start_-2):
        currentLayer=layer_start_+layer+1
        self.dna[currentLayer].append([[self.nodeStructure[currentLayer],[1, 0]]])
      self.dna[layer_end_-1].append([[row_end_,[1, 0]]])

  def DnaMutator(self, WB_rate, WC, BC):
    for N_Depth in range(len(self.dna)-1):
      Current_layer = self.dna[N_Depth]
      for Layer_size in range(len(Current_layer)):
        Current_Conections = Current_layer[Layer_size]
        for Connection in range(len(Current_Conections)):
            if(random.randint(0, 9999) < WB_rate*100):
              normal_away = np.random.default_rng().normal(size=5)[0]
              self.dna[N_Depth][Layer_size][Connection][1][0] += WC * normal_away
              normal_away = np.random.default_rng().normal(size=5)[0]
              self.dna[N_Depth][Layer_size][Connection][1][1] += BC * normal_away
              if(self.dna[N_Depth][Layer_size][Connection][1][1] < -.2):
                self.dna[N_Depth][Layer_size][Connection][1][1] = -.2
              if(self.dna[N_Depth][Layer_size][Connection][1][1] > .2):
                self.dna[N_Depth][Layer_size][Connection][1][1] = .2

  def testing(self, object):
    if(len(self.dna[0]) == len(object)):
      Output_row = []
      for N_Depth in range(len(self.dna)):
        Current_layer = []
        for Layer_size in range(len(self.dna[N_Depth])):
          if (N_Depth == 0):
            Current_layer.append(object[Layer_size])
          else:
            Current_layer.append(0)
        Output_row.append(Current_layer)
      for N_Depth in range(len(self.dna)-1):
        Current_layer = self.dna[N_Depth]
        for Layer_size in range(len(Current_layer)):
          Current_Conections = Current_layer[Layer_size]
          for Connection in range(len(Current_Conections)):
              Wieght_Bias = Current_Conections[Connection][1]
              Next_add = (Output_row[N_Depth][Layer_size]*Wieght_Bias[0] + Wieght_Bias[1])
              if(Next_add > 0):
                if(Current_Conections[Connection][0]<len(Output_row[N_Depth+1])):
                 Output_row[N_Depth+1][Current_Conections[Connection][0]] += Next_add
      for lastrowsig in range(len(Output_row[len(Output_row)-1])):
        Output_row[len(Output_row)-1][lastrowsig] = (Output_row[len(Output_row)-1][lastrowsig])
      return Output_row
    else:
      return "Incopatible types"
  def readAIStructureStats(self, print_level_Details_=2):
    print(f"AI Depth: {len(self.dna)-2}")
    print(f"InputSize: {len(self.dna[0])}")
    if(print_level_Details_>=1):
      for ind_ai_layer in range(len(self.dna)-1):
        if(ind_ai_layer==0):
          print(f"InputSize: {len(self.dna[ind_ai_layer])}")
        else:
          print(f"Layer{ind_ai_layer} length: {len(self.dna[ind_ai_layer])}")
        if(print_level_Details_>=2):
          for ind_ai_node in range(len(self.dna[ind_ai_layer])):
            print(f"  Node{ind_ai_node+1} length: {len(self.dna[ind_ai_layer][ind_ai_node])}")
    print(f"OutputSize: {len(self.dna[-1])}")
  def getAI(self):
    return self.dna

STARTING_INPUT_SIZE=126
STARTING_OUTPUT_SIZE = 7
STARTING_DNABASE = [STARTING_INPUT_SIZE,32, 32, 32, 32, STARTING_OUTPUT_SIZE]
STARTING_CONNECTIONS=16
POPULATION=10
GAMESPERAI = 1
TRIALS=3

def sigmoid(x):
  return 1 / (1 + math.exp(-x))
def proportianalfrequency(list_a):
  total=0
  for i in range(len(list_a)):
    if(list_a[i]>0):
      total+=list_a[i]
  if(total==0):
    return [.142,.142,.142,.142,.142,.142,.142]
  for i in range(len(list_a)):
    list_a[i]/=total
    if(list_a[i]<0):
      list_a[i]=0
  return list_a
def split_list(a_list):
    half = len(a_list)//2
    return a_list[:half], a_list[half:]
def getprevios(list, index):
  value = 0
  for i in range(index):
    value+=list[i]
  return value

def addChip(board, color, position):
  picked_y=5
  if(position<0 or 6<position):
    return  "invalie_move"
  else:
    notBottom=True
    for i in range(6):
      if(notBottom):
        if(board[i][position]!='N'):
          if(i==0):
            return "full";
          picked_y=i-1
          board[i-1]=board[i-1][:position] + color + board[i-1][position+1:]
          notBottom=False
          return [board, crosspass(board, position, picked_y)]
    board[5]=board[5][:position] + color + board[5][position+1:]
  return [board, crosspass(board, position, picked_y)]

def printBoard(board):
  for i in range(len(board)):
    print(board[i])

def OneHotEncoder(board):
  encodedBoard =[]
  for y in range(len(board)):
    encod_Holder=[]
    for x in range(7):
      if(board[y][x]=='N'):
        encod_Holder.append([1,0,0])
      if(board[y][x]=='R'):
        encod_Holder.append([0,1,0])
      if(board[y][x]=='Y'):
        encod_Holder.append([0,0,1])
    encodedBoard.append(encod_Holder)
  return encodedBoard

def Printboard(board):
  plotboard=[[0, 1.1, 1.1, 1.1, 1.1, 1.1, 0]]
  for y in range(len(board)):
    plot_Holder=[]
    for x in range(7):
      if(board[y][x]=='N'):
        plot_Holder.append(0)
      if(board[y][x]=='R'):
        plot_Holder.append(.4)
      if(board[y][x]=='Y'):
        plot_Holder.append(1)
    plotboard.append(plot_Holder)
  plt.imshow(plotboard, interpolation='none')
  plt.show()

def doesPass(word):
  count = 0
  letter = ''
  for i in range(len(word)):
    if(word[i]=='N'):
      count=0
      letter=''
    if(word[i]=='Y'):
      if(letter=='Y'):
        count+=1
      else:
        letter = 'Y'
        count=1
    if(word[i]=='R'):
      if(letter=='R'):
        count+=1
      else:
        letter = 'R'
        count=1
    if(count==4):
      return letter
  return 'no Winner'

def crosspass(board, x ,y):
  result='no Winner'
  result=doesPass(board[y])
  if(result!='no Winner'):
    return [result, 'Horizontal']

  letters=board[0][x]+board[1][x]+board[2][x]+board[3][x]+board[4][x]+board[5][x]
  result=doesPass(letters)
  if(result!='no Winner'):
    return [result, 'Vertical']

  letters=board[y][x]
  lettersbehind = ""
  i=0
  while(x+i<6 and y+i<5):
    i+=1
    letters+=board[y+i][x+i]
  i=0
  while(x-i>0 and y-i>0):
    i+=1
    lettersbehind+=board[y-i][x-i]
  result=doesPass(lettersbehind[::-1]+letters)
  if(result!='no Winner'):
    return [result, 'DownSlope']

  letters=board[y][x]
  lettersbehind = ""
  i=0
  while(x+i<6 and y-i>0):
    i+=1
    letters+=board[y-i][x+i]
  i=0
  while(x-i>0 and y+i<5):
    i+=1
    lettersbehind+=board[y+i][x-i]
  result=doesPass(lettersbehind[::-1]+letters)
  if(result!='no Winner'):
    return [result, 'UpSlope']
  return ["noWin", "noWin"]



def GetInputs(encoded_board):
  Input=[]
  for y in range(len(encoded_board)):
    for x in range(len(encoded_board[y])):
      for onehot in range(3):
        Input.append(encoded_board[y][x][onehot])
  return Input

def MakeStartingAI(DnaSize, Max_Connections, Full_connection=False):
  Dna = []
  rng=np.random.default_rng()
  for N_Depth in range(len(DnaSize)-1):
    Layer_holder = []
    for Layer_size in range(DnaSize[N_Depth]):
      Connention_holder=[]
      if(Full_connection == True):
        for Connection in range(DnaSize[N_Depth+1]):
          Neron_output = []
          Neron_output.append(Connection)
          Neron_output.append([0, 0])
          Connention_holder.append(Neron_output)
        Layer_holder.append(Connention_holder)
      else:
        for Connection in range(Max_Connections):
          Neron_output = []
          Neron_output.append(random.randint(-1, DnaSize[N_Depth+1]-1))
          if (Neron_output[0] != -1):
            Neron_output.append([rng.normal(0, 2), rng.normal(0, .02)])
          Connention_holder.append(Neron_output)
        Layer_holder.append(Connention_holder)
    Dna.append(Layer_holder)
  Finalrow = []
  for final_output in range(DnaSize[len(DnaSize)-1]):
    Finalrow.append(final_output)
  Dna.append(Finalrow)
  return Dna



def DnaMutator(Dna_old, Disconnect_rate, Connect_rate, WB_rate, WC, BC):
  Dna = Dna_old
  for N_Depth in range(len(Dna_old)-1):
    Current_layer = Dna_old[N_Depth]
    for Layer_size in range(len(Current_layer)):
      Current_Conections = Current_layer[Layer_size]
      for Connection in range(len(Current_Conections)):
        if (Current_Conections[Connection][0] == -1):
          if(random.randint(0, 9999) < Connect_rate*100):#Persision down to .01%
            normal_away = np.random.default_rng().normal(size=5)[0]
            Dna[N_Depth][Layer_size][Connection] = [random.randint(0, len(Dna_old[N_Depth+1])-1),[WC*normal_away, BC*normal_away]]
        else:
          if(random.randint(0, 9999) < Disconnect_rate*100):
            Dna[N_Depth][Layer_size][Connection] = [-1]
          else:
            if(random.randint(0, 9999) < WB_rate*100):
              normal_away = np.random.default_rng().normal(size=5)[0]
              if (random.randint(0,1)==0):
                Dna[N_Depth][Layer_size][Connection][1][0] *=  math.pow(random.randint(0,100),2)/2500
                Dna[N_Depth][Layer_size][Connection][1][0] += WC*normal_away
                if(Dna[N_Depth][Layer_size][Connection][1][0] < -80):
                  Dna[N_Depth][Layer_size][Connection][1][0] = -80
                if(Dna[N_Depth][Layer_size][Connection][1][0] > 80):
                  Dna[N_Depth][Layer_size][Connection][1][0] = 80
              else:
                Dna[N_Depth][Layer_size][Connection][1][1] *= math.pow(random.randint(0,100),2)/2500
                Dna[N_Depth][Layer_size][Connection][1][1] += BC*normal_away
                if(Dna[N_Depth][Layer_size][Connection][1][1] < -.2):
                  Dna[N_Depth][Layer_size][Connection][1][1] = -.2
                if(Dna[N_Depth][Layer_size][Connection][1][1] > .2):
                  Dna[N_Depth][Layer_size][Connection][1][1] = .2
  return Dna

def testing(Dna, object):
  if(len(Dna[0]) == len(object)):
    Output_row = []
    for N_Depth in range(len(Dna)):
      Current_layer = []
      for Layer_size in range(len(Dna[N_Depth])):
        if (N_Depth == 0):
          Current_layer.append(object[Layer_size])
        else:
          Current_layer.append(0)
      Output_row.append(Current_layer)
    for N_Depth in range(len(Dna)-1):
      Current_layer = Dna[N_Depth]
      for Layer_size in range(len(Current_layer)):
        Current_Conections = Current_layer[Layer_size]
        for Connection in range(len(Current_Conections)):
          if (Current_Conections[Connection][0] != -1):
            Wieght_Bias = Current_Conections[Connection][1]
            Next_add = (Output_row[N_Depth][Layer_size]*Wieght_Bias[0] + Wieght_Bias[1])
            if(Next_add > 0):
              Output_row[N_Depth+1][Current_Conections[Connection][0]] += Next_add
    for lastrowsig in range(len(Output_row[len(Output_row)-1])):
      Output_row[len(Output_row)-1][lastrowsig] = (Output_row[len(Output_row)-1][lastrowsig])
    return Output_row
  else:
    return "Incopatible types"

def MutateAIlistup(amount, Dnalist):
  DnalistC = copy.deepcopy(Dnalist)
  Dnal = []
  extra = amount-len(Dnalist)
  for i in range(len(Dnalist)):
    for x in range(int(amount/len(Dnalist))+1):
      if(x==0):
        Dnal.append(DnalistC[i])
      else:
        if(extra>0):
          extra-=1
          DnaMutated = copy.deepcopy(DnalistC[i])
          if (random.randint(1,1000)>950):
            DnaMutated = DnaMutator(DnaMutated, 0, 100 ,2, 16, .01)
          else:
             DnaMutated = DnaMutator(DnaMutated, 0, 100 ,.5, 5, .01)
          Dnal.append(DnaMutated)
  return Dnal

def pickedMove(Outputs, emptyOutputs, board, doesPrint=False):
  move=-1
  for i in range(7):
    Outputs[i]-=emptyOutputs[i]
  Outputs=proportianalfrequency(Outputs)
  if(doesPrint):
    print(Outputs)
  for i in range(7):
    if(board[0][i]!='N'):
      Outputs[i]=0
  Outputs=proportianalfrequency(Outputs)
  pickedvalue=random.randint(0,100)
  if(doesPrint):
    print(pickedvalue)
  for i in range(7):
    if(board[0][i]=='N'):
        Outputs[i]*=100
        if(pickedvalue<Outputs[i]):
          if(move==-1):
            move=i
        else:
          pickedvalue-=Outputs[i]
  if(move==-1):
    return "No Valid Move"
  for i in range(7):
    if(board[0][i]=='N'):
      if(Outputs[move]<Outputs[i]):
        move=i
  return move

def RunNetwork(board, Ai, color,doesPrint=False):
  emptyboard=["NNNNNNN",
      "NNNNNNN",
      "NNNNNNN",
      "NNNNNNN",
      "NNNNNNN",
      "NNNNNNN"]
  ai_Inputs=GetInputs(OneHotEncoder(emptyboard))
  emptyhold=testing(Ai,ai_Inputs)
  emptyoutputs=emptyhold[len(emptyhold)-1]
  ai_Inputs=GetInputs(OneHotEncoder(board))
  hold=testing(Ai,ai_Inputs)
  outputs=hold[len(hold)-1]
  ai_move=pickedMove(outputs, emptyoutputs, board, doesPrint)
  if(ai_move=="No Valid Move"):
    return "No Valid Move"
  chip_info=addChip(board, color, ai_move)
  board=chip_info[0]
  return chip_info[1][0]

def findWinner(ai_attacker, ai_deffender, trials, doesPrint=False):
  score=0
  for i in range (trials):
    board=["NNNNNNN",
        "NNNNNNN",
        "NNNNNNN",
        "NNNNNNN",
        "NNNNNNN",
        "NNNNNNN"]
    winner="noWin"
    while (winner=="noWin"):
      winner=RunNetwork(board, ai_attacker, 'Y', (doesPrint and (i==trials-1)))
      if(winner=="noWin"):
        winner=RunNetwork(board, ai_deffender, 'R', (doesPrint and (i==trials-1)))
        if(winner!="noWin"):
            score-=1
      else:
        score+=1
      if(doesPrint and (i==trials-1)):
        Printboard(board)
  if(score>=trials/2+1):
    winner='Y'
  else:
    winner='R'
  if((doesPrint)):
    Printboard(board)
    print(score)
    print(winner)
  return winner

def verticalSpam(deffendingAI, printGame):
 board=["NNNNNNN",
      "NNNNNNN",
      "NNNNNNN",
      "NNNNNNN",
      "NNNNNNN",
      "NNNNNNN"]
 winner="noWin"
 pickedColumn=[0,1,2,3,4,5,6]
 random.shuffle(pickedColumn)
 index=0
 while (winner=="noWin"):
    if(board[0][pickedColumn[index]]!='N'):
      index+=1
      if(index==7):
        return "noWin"
    chip_info=addChip(board, 'Y', pickedColumn[index])
    board=chip_info[0]
    winner=chip_info[1][0]
    if(winner=="noWin"):
      winner=RunNetwork(board, deffendingAI, 'R',printGame)
    if(printGame):
      Printboard(board)
 return winner

def testandChopSkill(ai_list, difficulty=[1,1]):
  survived_ai_list=[]
  printGame=False
  for i in range(POPULATION):
    score=0
    for x in range(difficulty[1]):
      if(i==POPULATION-1 and x==(difficulty[1]-1)):
        printGame=True
        print(score)
      winner=verticalSpam(ai_list[i],printGame)
      if(winner=='R'):
        score+=1
      if(winner=="noWin"):
         score+=1
    if(score>=difficulty[0]):
      survived_ai_list.append(ai_list[i])
  if(len(survived_ai_list)==0):
    print("dedmanA")
    survived_ai_list.append(ai_list[0])
  return survived_ai_list

def testandChop(attacking_ai_list, deffending_ai_list, trials=TRIALS):
  survived_attacking_ai_list=[]
  survived_deffending_ai_list=[]
  printGame=False
  for i in range(POPULATION):
    if(i==POPULATION-1):
      printGame=True
    winner=findWinner(attacking_ai_list[i],deffending_ai_list[i], trials, printGame)
    if(winner=='Y'):
      survived_attacking_ai_list.append(attacking_ai_list[i])
    if(winner=='R'):
      survived_deffending_ai_list.append(deffending_ai_list[i])
    if(winner=="noWin"):
      survived_attacking_ai_list.append(attacking_ai_list[i])
      survived_deffending_ai_list.append(deffending_ai_list[i])
  if(len(survived_attacking_ai_list)<=5):
    print("dedmanA")
    for i in range(5):
      survived_attacking_ai_list.append(attacking_ai_list[i])
  if(len(survived_deffending_ai_list)<=5):
    print("dedmanD")
    for i in range(5):
      survived_deffending_ai_list.append(deffending_ai_list[i])
  return [survived_attacking_ai_list, survived_deffending_ai_list]

def playAI(AI, board):
  winner=RunNetwork(board, AI, 'Y')
  return board

def DataFrameToDna(Data, Connection_rate=STARTING_DNABASE, DnaSize=STARTING_DNABASE, InString=True):
  Dna = []
  print(DnaSize)
  for N_Depth in range(len(DnaSize)-1):
    Layer_holder = []
    for Layer_size in range(DnaSize[N_Depth]):
      Connection_holder=[]
      for Connection in range(Connection_rate[N_Depth+1]):
        if(InString==True):
          Connection_holder.append(ast.literal_eval(Data[str(Connection)][Layer_size+getprevios(DnaSize, N_Depth)]))
        else:
          Connection_holder.append(Data[Connection][Layer_size+getprevios(DnaSize, N_Depth)])
      Layer_holder.append(Connection_holder)
    Dna.append(Layer_holder)
  Finalrow = []
  for final_output in range(DnaSize[len(DnaSize)-1]):
    Finalrow.append(final_output)
  Dna.append(Finalrow)
  return Dna

def DnaToDataFrame(Dna):
  Datalist = []
  for N_Depth in range(len(Dna)-1):
    for Layer_size in range(len(Dna[N_Depth])):
      Datalist.append(Dna[N_Depth][Layer_size])
  DataFrame = pd.DataFrame(Datalist)
  return DataFrame

board = ["NNNNNNN",
      "NNNNNNN",
      "NNNNNNN",
      "NNNNNNN",
      "NNNNNNN",
      "NNNNNNN"]

addChip(board, "R", 4)

POPULATION=10

attackingAI = MakeStartingAI(STARTING_DNABASE, STARTING_CONNECTIONS, True)
attacking_AI_List=MutateAIlistup(POPULATION, [attackingAI])
deffendingAI = MakeStartingAI(STARTING_DNABASE, STARTING_CONNECTIONS, True)
deffending_AI_List=MutateAIlistup(POPULATION, [deffendingAI])

POPULATION=300
start_time = time.time()
deffending_AI_List=MutateAIlistup(POPULATION, deffending_AI_List)
end_time = time.time()
print(end_time-start_time)

attackWinrate=[]

n=np.random.randn(1, 5)

n

difficulty=[[1,1],[2,2],[3,3],[4,4],[5,5]]
index=0
for i in range(1000):
  deffending_AI_List=testandChopSkill(deffending_AI_List,difficulty[index])
  print(len(deffending_AI_List))
  if(len(deffending_AI_List)/POPULATION>.6):
    index+=1
    print(difficulty[index])
  attackWinrate.append(len(deffending_AI_List)/POPULATION)
  plt.plot(attackWinrate)
  plt.title("DefendWR")
  plt.show()
  random.shuffle(deffending_AI_List)
  deffending_AI_List=MutateAIlistup(POPULATION, deffending_AI_List)

deffending_AI_List[0].readAIStructureStats(0)

POPULATION=200
start_time = time.time()
attacking_AI_List=MutateAIlistup(POPULATION, attacking_AI_List)
deffending_AI_List=MutateAIlistup(POPULATION, deffending_AI_List)
end_time = time.time()
print(end_time-start_time)

attackWinrate=[]

for i in range(1000):
  attacking_AI_List, deffending_AI_List=testandChop(attacking_AI_List, deffending_AI_List)
  print(len(attacking_AI_List))
  print(len(deffending_AI_List))
  random.shuffle(attacking_AI_List)
  random.shuffle(deffending_AI_List)
  attackWinrate.append(len(attacking_AI_List)/POPULATION)
  plt.plot(attackWinrate)
  plt.title("AttackWR")
  plt.show()
  attacking_AI_List=MutateAIlistup(POPULATION, attacking_AI_List)
  deffending_AI_List=MutateAIlistup(POPULATION, deffending_AI_List)

board=["NNNNNNN",
      "NNNNNNN",
      "NNNNNNN",
      "NNNNNNN",
      "NNNNNNN",
      "NNNNNNN"]
winner="noWin"

addChip(board, "R", 3)
winner=RunNetwork(board, deffending_AI_List[10], 'Y', True)
Printboard(board)
if(winner=='R'):
  print("Lost")
if(winner=='Y'):
  print("Win")

board=["NNNNNNN",
      "NNNNNNN",
      "NNNNNNN",
      "NNNNNNN",
      "NNNNNNN",
      "NNNNNNN"]
winner="noWin"
winner=RunNetwork(board, attacking_AI_List[0], 'Y', True)
Printboard(board)

addChip(board, "R", 3)
winner=RunNetwork(board, attacking_AI_List[10], 'Y', True)
Printboard(board)
if(winner=='R'):
  print("Lost")
if(winner=='Y'):
  print("Win")

attackWinrate=[]
defendWinrate=[]

POPULATION=200
start_time = time.time()
attacking_AI_List=MutateAIlistup(POPULATION, attacking_AI_List)
deffending_AI_List=MutateAIlistup(POPULATION, deffending_AI_List)
end_time = time.time()
print(end_time-start_time)

for x in range(200):
  print("defend")
  for i in range(2):
    deffending_AI_List=testandChopSkill(deffending_AI_List,[1,1])
    print(len(deffending_AI_List))
    defendWinrate.append(len(deffending_AI_List)/POPULATION)
    plt.plot(defendWinrate)
    plt.title("DefendWR")
    plt.show()
    random.shuffle(deffending_AI_List)
    deffending_AI_List=MutateAIlistup(POPULATION, deffending_AI_List)
  print("attack")
  for i in range(2):
    attacking_AI_List, deffending_AI_List=testandChop(attacking_AI_List, deffending_AI_List)
    print(len(attacking_AI_List))
    print(len(deffending_AI_List))
    random.shuffle(attacking_AI_List)
    random.shuffle(deffending_AI_List)
    attackWinrate.append(len(attacking_AI_List)/POPULATION)
    plt.plot(attackWinrate)
    plt.title("AttackWR")
    plt.show()
    deffending_AI_List+=attacking_AI_List
    random.shuffle(deffending_AI_List)
    attacking_AI_List, deffending_AI_List = split_list(deffending_AI_List)
    deffending_AI_List=MutateAIlistup(POPULATION, attacking_AI_List)
    attacking_AI_List=MutateAIlistup(POPULATION, attacking_AI_List)

DnaToDataFrame(attacking_AI_List[0]).to_csv(("Gen2Connect4"), index=False)

ai=DataFrameToDna(pd.read_csv("Gen2Connect4"))

ai