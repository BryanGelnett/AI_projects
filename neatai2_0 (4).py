# -*- coding: utf-8 -*-
"""NeatAI2.0

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZlBlhYIAsG4KRz36hgwJASo3aYKjsodu
"""

import random
import math
import pickle

class HelperFuncitons:
  def getNumberInbetween(self, list_, start_, end_):
    total=0;
    for i in range(end_-start_):
      total+=list_[i+start_]
    return total
  def chanceMultiplier(self, bounds):
    chance=math.pow(2, bounds*(2*random.random()-1))
    return chance
  def proportianalfrequency(self, list_a_):
    total=0
    for i in range(len(list_a_)):
      if(list_a_[i]>0):
        total+=list_a_[i]
    if(total==0):
      return [1/len(list_a_)]*len(list_a_)
    for i in range(len(list_a_)):
      list_a_[i]/=total
      if(list_a_[i]<0):
        list_a_[i]=0
    return list_a_
  def pickPoportionalRandom(self, list_a_):
    list_a = self.proportianalfrequency(list_a_)
    picked=random.random()
    for i in range(len(list_a_)):
      if(picked<=list_a[i]):
        return i
      else:
        picked-=list_a[i]
    return len(list_a_)-1

class Connection():
    def __init__(self, layer_, row_):
      self.helper = HelperFuncitons()
      self.output_layer=layer_
      self.output_row=row_
      self.weight=0
      self.bias=0

    def getOutputLayer(self):
      return self.output_layer

    def getOutputRow(self):
      return self.output_row

    def setMutateRate(self, multWieghtRate_, addWieghtRate_, chanceWieghtRate_, multBiasRate_, addBiasRate_, chanceBiasRate_):
      self.wieght_multiplier_mutation_Rate=multWieghtRate_
      self.wieght_additive_mutation_Rate=addWieghtRate_
      self.wieght_chance_mutation_Rate=chanceWieghtRate_
      self.bias_multiplier_mutation_Rate=multBiasRate_
      self.bias_additiv_mutation_Rate=addBiasRate_
      self.bias_chance_mutation_Rate=chanceBiasRate_

    def changeMutateRate(self, multWieghtRate_, addWieghtRate_, chanceWieghtRate_, multBiasRate_, addBiasRate_, chanceBiasRate_):
      self.wieght_multiplier_mutation_Rate*=multWieghtRate_
      self.wieght_additive_mutation_Rate*=addWieghtRate_
      self.wieght_chance_mutation_Rate*=chanceWieghtRate_
      self.bias_multiplier_mutation_Rate*=multBiasRate_
      self.bias_additiv_mutation_Rate*=addBiasRate_
      self.bias_chance_mutation_Rate*=chanceBiasRate_

    def mutateWieght(self):
       if(random.random()<self.wieght_chance_mutation_Rate):
        self.weight+=self.wieght_additive_mutation_Rate
        self.weight*=self.helper.chanceMultiplier(self.wieght_multiplier_mutation_Rate)

    def mutateBias(self):
      if(random.random()<self.bias_chance_mutation_Rate):
        self.bias+=self.bias_additiv_mutation_Rate*(2*random.random()-1)
        self.bias*=self.helper.chanceMultiplier(self.bias_multiplier_mutation_Rate)

    def runCalculation(self, input_):
      connection_Output=self.weight*input_ + self.bias
      return max(connection_Output,0)

    def blockifyConnection(self):
      return [[self.output_layer, self.output_row], [self.weight, self.bias]]

class Node():
    def __init__(self, layer_, row_):
      self.helper = HelperFuncitons()
      self.output_Layer=layer_
      self.output_Row=row_
      self.weight=1
      self.bias=0
      self.connections=[]

    def setStructureRate(self, sprout_Rate_, send_Connect_Rate_, recieve_Connect_Rate_):
      self.sprout_Rate=sprout_Rate_
      self.send_Connect_Rate=send_Connect_Rate_
      self.recieve_Connect_Rate=recieve_Connect_Rate_

    def changeStructureRate(self, sprout_Rate_, send_Connect_Rate_, recieve_Connect_Rate_):
      self.sprout_Rate*=sprout_Rate_
      self.send_Connect_Rate*=send_Connect_Rate_
      self.recieve_Connect_Rate*=recieve_Connect_Rate_

    def addConnection(self, outputLayer_, outputRow_):
      new_Connection=Connection(outputLayer_, outputRow_)
      new_Connection.setMutateRate(.1, .02, .1, .1, .01, .1)
      self.connections.append(new_Connection)

    def changeConnectionMutateRate(self):
      for ind_Connection in range(len(self.connections)):
        mutation_Changes=[1]*6
        for i in range(len(mutation_Changes)):
          if(random.random()<.002):
            mutation_Changes[i]=self.helper.chanceMultiplier(random.random())
        self.connections[ind_Connection].changeMutateRate(mutation_Changes[0],mutation_Changes[1],mutation_Changes[2],mutation_Changes[3],mutation_Changes[4],mutation_Changes[5])

    def mutateConnections(self):
      for ind_Connection in range(len(self.connections)):
        self.connections[ind_Connection].mutateWieght()
        self.connections[ind_Connection].mutateBias()
        self.changeConnectionMutateRate()

    def numConnection(self):
      return self.connections.size()

    def getConnection(self, index_):
      return self.connections[index_]


    def getRecieveConnectionRate(self):
      return self.recieve_Connect_Rate

    def getSendConnectionRate(self):
      return self.send_Connect_Rate

    def getSproutRate(self):
      return self.sprout_Rate

    def Ntesting(self, made_Output_, input_layer_, input_node_):
      for ind_Connection in range(len(self.connections)):
        current_Connection=self.connections[ind_Connection]
        made_Output_[current_Connection.getOutputLayer()][current_Connection.getOutputRow()]+=current_Connection.runCalculation(made_Output_[input_layer_][input_node_])

    def blockifyNode(self):
      blockNodes=[]
      for ind_Connection in range(len(self.connections)):
        blockNodes.append(self.connections[ind_Connection].blockifyConnection())
      return blockNodes

class Layer():
    def __init__(self, layer_):
      self.helper = HelperFuncitons()
      self.layer=layer_
      self.nodes=[]

    def addNode(self):
      newNode=Node(self.layer,len(self.nodes))
      newNode.setStructureRate(.001,.01, 1)
      self.nodes.append(newNode)

    def getNode(self, index_):
      return self.nodes[index_]

    def mutateNodes(self):
      for ind_Node in range(len(self.nodes)):
        self.nodes[ind_Node].mutateConnections()

    def numNodes(self):
      return len(self.nodes)

    def changeNodeMutateRate(self):
      self.changeStructureMutateRate()
      for ind_Node in range(len(self.nodes)):
        self.nodes[ind_Node].changeConnectionMutateRate()

    def sproutNode(self, index_, layer_, row_):
      current_Node=self.nodes[index_]
      if(current_Node.getSproutRate()>random.random()):
        current_Node.addConnection(layer_,row_)
        return True
      return False

    def addConnection(self, index_, layer_, row_):
      current_Node=self.nodes[index_]
      if(current_Node.getSendConnectionRate()>random.random()):
        self.nodes[index_].addConnection(layer_,row_)
        return True
      return False

    def getLayerNodeProbability(self):
      total=0
      for ind_Node in range(len(self.nodes)):
        total+=self.nodes[ind_Node].getRecieveConnectionRate()
      return total

    def pickConnectionProbability(self):
      node_probability=[]
      for ind_Node in range(len(self.nodes)):
        node_probability.append(self.nodes[ind_Node].getRecieveConnectionRate())
      return self.helper.pickPoportionalRandom(node_probability)

    def changeStructureMutateRate(self):
      for ind_Node in range(len(self.nodes)):
        mutation_Changes=[1]*3
        for i in range(len(mutation_Changes)):
          if(random.random()<.002):
            mutation_Changes[i]=self.helper.chanceMultiplier(random.random())
        self.connections[ind_Node].changeStructureRate(mutation_Changes[0],mutation_Changes[1],mutation_Changes[2])

    def Ltesting(self, made_Output_, input_Layer_):
      for ind_Node in range(len(self.nodes)):
        current_Node=self.nodes[ind_Node]
        current_Node.Ntesting(made_Output_, input_Layer_, ind_Node)

    def blockifyLayer(self):
      blockLayers=[]
      for ind_Node in range(len(self.nodes)):
        blockLayers.append(self.nodes[ind_Node].blockifyNode())
      return blockLayers

class NeatAI():
    def __init__(self, input_Size_, output_Size_):
      self.helper = HelperFuncitons()
      self.layers=[]
      self.input_Layer=Layer("InputLayer")
      self.output_Layer=Layer("OutputLayer")
      self.input_Grouping=[[]]
      self.output_Grouping=[[]]
      for i in range(input_Size_):
        self.input_Grouping[0].append(i)
        self.input_Layer.addNode()
      for i in range(output_Size_):
        self.output_Grouping[0].append(i)
        self.output_Layer.addNode()

    def save(self, name):
      with open(name +'.pkl', 'wb') as f:
        pickle.dump(self, f)

    def increaseInput(self, type_=0, amount_=1):
      if(type_>=len(self.input_Grouping)):
          self.input_Grouping.append([])
      for i in range(amount_):
        self.input_Grouping[type_].append(self.input_Layer.numNodes())
        self.input_Layer.addNode()

    def getNumInputType(self):
      return len(self.input_Grouping())

    def increaseOutput(self, type_=0, amount_=1):
      if(type_>=len(self.output_Grouping)):
        self.output_Grouping.append([])
      for i in range(amount_):
        self.output_Grouping[type_].append(self.output_Layer.numNodes())
        self.output_Layer.addNode()

    def getOutputs(self, inputs_):
      inputs=([0]*self.input_Layer.numNodes())
      for ind_input_Groop in range(len(inputs_)):
        for ind_input in range(len(inputs_[ind_input_Groop])):
          inputs[self.input_Grouping[ind_input_Groop][ind_input]]=inputs_[ind_input_Groop][ind_input]
      unorderd_Output=self.testing(inputs)
      unorderd_Output=unorderd_Output[len(unorderd_Output)-1]
      output=[]
      for ind_Output_Groop in range(len(self.output_Grouping)):
        output.append([0]*len(self.output_Grouping[ind_Output_Groop]))
        for ind_Output in range(len(self.output_Grouping[ind_Output_Groop])):
          output[ind_Output_Groop][ind_Output]=unorderd_Output[self.output_Grouping[ind_Output_Groop][ind_Output]]
      return output

    def totalNodes(self):
      total=0
      for ind_Layer in range(len(self.layers)):
        total+=self.layers[ind_Layer].numNodes()
      total+=self.input_Layer.numNodes()
      total+=self.output_Layer.numNodes()
      return total

    def mutateAI(self, mutations_, connections_, nodes_):
      for i in range(mutations_):
        self.mutateAIWB()
      for i in range(connections_):
        for ind_layer in range(len(self.layers)+1):
          self.sproutConnection(ind_layer)
      for i in range(nodes_):
        for ind_layer in range(len(self.layers)+1):
          self.sproutNode(ind_layer)

    def sproutNode(self, layer_):
      recieve_Layer, recieve_Row = self.getRecieveNode(layer_+1)
      if(layer_==0):
        send_Layer=self.input_Layer
      else:
        send_Layer=self.layers[layer_-1]
      if(layer_==len(self.layers)):
         node_row=0
      else:
        node_row=self.layers[layer_].numNodes()
      for ind_Node in range(send_Layer.numNodes()):
        if(send_Layer.sproutNode(ind_Node, layer_+1, node_row)):
          if(layer_==len(self.layers)):
            self.layers.append(Layer(len(self.layers)))
          recieve_Layer, recieve_Row = self.getRecieveNode(layer_+1)
          node_Layer=self.layers[layer_]
          node_Layer.addNode()
          node_Layer.getNode(-1).addConnection(recieve_Layer, recieve_Row)

    def sproutConnection(self, layer_):
      recieve_Layer, recieve_Row = self.getRecieveNode(layer_)
      if(layer_==0):
        send_Layer=self.input_Layer
      else:
        send_Layer=self.layers[layer_-1]
      for ind_Node in range(send_Layer.numNodes()):
        if(send_Layer.addConnection(ind_Node, recieve_Layer, recieve_Row)):
          recieve_Layer, recieve_Row = self.getRecieveNode(layer_)

    def mutateAIWB(self):
      self.input_Layer.mutateNodes()
      for ind_Layer in range(len(self.layers)):
        self.layers[ind_Layer].mutateNodes()

    def getRecieveNode(self, layer_):
      layer_probability=[]
      for ind_Layer in range(len(self.layers)-layer_):
        layer_probability.append(self.layers[ind_Layer+layer_].getLayerNodeProbability())
      layer_probability.append(self.output_Layer.getLayerNodeProbability())
      picked_Layer=self.helper.pickPoportionalRandom(layer_probability)+layer_
      if(picked_Layer>=len(self.layers)):
        picked_Layer=-1
        recieve_Layer=self.output_Layer
      else:
        recieve_Layer=self.layers[picked_Layer]
        picked_Layer+=1
      return [picked_Layer, recieve_Layer.pickConnectionProbability()]

    def testing(self, input_):
      made_Output = self.outputMaker(input_)
      self.input_Layer.Ltesting(made_Output,0)
      for ind_Layer in range(len(self.layers)):
        current_Layer=self.layers[ind_Layer]
        current_Layer.Ltesting(made_Output,ind_Layer+1)
      return made_Output

    def outputMaker(self, input_):
      made_Output=[]
      made_Output.append(input_)
      for ind_Layer in range(len(self.layers)):
        made_Output.append(self.layers[ind_Layer].numNodes()*[0])
      made_Output.append(self.output_Layer.numNodes()*[0])
      return made_Output

    def blockifyAI(self):
      block=[]
      block.append(self.input_Layer.blockifyLayer())
      for ind_Layer in range(len(self.layers)):
        block.append(self.layers[ind_Layer].blockifyLayer())
      block.append(self.output_Layer.blockifyLayer())
      return block