# -*- coding: utf-8 -*-
"""MazeMemory

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V2RrC_NjI6tSoj-3GAsrM7G95YIzWgnb
"""

import numpy as np
import tensorflow as tf
import keras
import math
import pandas as pd
import matplotlib.pyplot as plt
from keras import layers
import random
import ast
import copy
import csv

AI_EYES_X = 5#vision sizex
AI_EYES_Y = 5#vision sizey
START_MEMCALLB_SIZE = 1 #detail in memory reteval
START_MEM_SIZE = 1 #detail in memory
START_MEM_INPUTS = 1 #number of memories processed at one time
START_REINPUT_SIZE = 2 #Ai imeadiate recamunication
STARTING_CONNECTIONS = 32
DESENDENT_RATE = 2 #always 2 or greater
AMOUNT_PICKED = 100
TRIALS = 20
STARTING_INPUT_SIZE = AI_EYES_X*AI_EYES_Y*4+START_MEM_SIZE*START_MEM_INPUTS+START_REINPUT_SIZE
STARTING_OUTPUT_SIZE = 4+START_REINPUT_SIZE+START_MEMCALLB_SIZE+START_MEM_SIZE+2
STARTING_DNABASE = [STARTING_INPUT_SIZE,8,8,8,STARTING_OUTPUT_SIZE]
POPULATION=DESENDENT_RATE*AMOUNT_PICKED

STARTING_OUTPUT_SIZE



"""*eyes/memory vis
*chat/resonse
//paper
*memory[[Gs, Importance, Storage, decay]calback1[8],info[64]]

"""

def pathogorean(a, b):
  return math.sqrt(math.pow(a, 2)+math.pow(b, 2))
def MakeMatrix(xl=AI_EYES_X, yl=AI_EYES_Y):
  Image = []
  for y in range(yl):
   holder = []
   for x in range(xl):
     holder.append(0)
   Image.append(holder)
  return Image
def flattenMatrix(matrix):
  flattenmatrix = []
  for y in range(len(matrix)):
    for x in range(len(matrix[0])):
      flattenmatrix.append(matrix[y][x])
  return flattenmatrix
def UnflattenMatrix(matrix, sizex=AI_EYES_X, sizey=AI_EYES_Y):
  Unflattenedmatrix = []
  for x in range(sizex):
    holder = []
    for y in range(sizey):
      holder.append(matrix[x*sizex+y])
    Unflattenedmatrix.append(holder)
  return Unflattenedmatrix
def sigmoid(x):
  if(x>20):
    return 1
  elif(x<-20):
    return 0
  else:
    return 1 / (1 + math.exp(-x))
def getprevios(list, index):
  value = 0
  for i in range(index):
    value+=list[i]
  return value
def proportianalfrequency(list_a):
  total=0
  for i in range(len(list_a)):
    if(list_a[i]>0):
      total+=list_a[i]
  if(total==0):
    return [1/len(list_a)]*len(list_a)
  for i in range(len(list_a)):
    list_a[i]/=total
    if(list_a[i]<0):
      list_a[i]=0
  return list_a



def GetInputs(aiEyes, memories, reInput):
  Input = []
  for y in range(len(aiEyes)):
    for x in range(len(aiEyes[0])):
      for onehot in range(4):
        Input.append(aiEyes[y][x][onehot])
  for mem in range(len(memories)):
    for node in range(len(memories[0])):
      Input.append(memories[mem][node])
  for reinput in range(len(reInput)):
    Input.append(reInput[reinput])
  return Input

#MazeMaker-not my code
def surroundingCells(rand_wall, width, height, maze):
	s_cells = 0
	if (maze[rand_wall[0]-1][rand_wall[1]] == 0):
		s_cells += 1
	if (maze[rand_wall[0]+1][rand_wall[1]] == 0):
		s_cells += 1
	if (maze[rand_wall[0]][rand_wall[1]-1] == 0):
		s_cells +=1
	if (maze[rand_wall[0]][rand_wall[1]+1] == 0):
		s_cells += 1

	return s_cells


## Main code
# Init variables
def MakeMaze(width, height):
	wall = .5
	cell = 0
	unvisited = .2
	maze = []

	# Denote all cells as unvisited
	for i in range(0, height):
		line = []
		for j in range(0, width):
			line.append(unvisited)
		maze.append(line)

	# Randomize starting point and set it a cell
	starting_height = int(random.random()*height)
	starting_width = int(random.random()*width)
	if (starting_height == 0):
		starting_height += 1
	if (starting_height == height-1):
		starting_height -= 1
	if (starting_width == 0):
		starting_width += 1
	if (starting_width == width-1):
		starting_width -= 1

	# Mark it as cell and add surrounding walls to the list
	maze[starting_height][starting_width] = cell
	walls = []
	walls.append([starting_height - 1, starting_width])
	walls.append([starting_height, starting_width - 1])
	walls.append([starting_height, starting_width + 1])
	walls.append([starting_height + 1, starting_width])

	# Denote walls in maze
	maze[starting_height-1][starting_width] = .5
	maze[starting_height][starting_width - 1] = .5
	maze[starting_height][starting_width + 1] = .5
	maze[starting_height + 1][starting_width] = .5

	while (walls):
		# Pick a random wall
		rand_wall = walls[int(random.random()*len(walls))-1]

		# Check if it is a left wall
		if (rand_wall[1] != 0):
			if ((maze[rand_wall[0]][rand_wall[1]-1] == .2) and (maze[rand_wall[0]][rand_wall[1]+1] == 0)):
				# Find the number of surrounding cells
				s_cells = surroundingCells(rand_wall, width, height, maze)

				if (s_cells < 2):
					# Denote the new path
					maze[rand_wall[0]][rand_wall[1]] = 0

					# Mark the new walls
					# Upper cell
					if (rand_wall[0] != 0):
						if (maze[rand_wall[0]-1][rand_wall[1]] != 0):
							maze[rand_wall[0]-1][rand_wall[1]] = .5
						if ([rand_wall[0]-1, rand_wall[1]] not in walls):
							walls.append([rand_wall[0]-1, rand_wall[1]])


					# Bottom cell
					if (rand_wall[0] != height-1):
						if (maze[rand_wall[0]+1][rand_wall[1]] != 0):
							maze[rand_wall[0]+1][rand_wall[1]] = .5
						if ([rand_wall[0]+1, rand_wall[1]] not in walls):
							walls.append([rand_wall[0]+1, rand_wall[1]])

					# Leftmost cell
					if (rand_wall[1] != 0):
						if (maze[rand_wall[0]][rand_wall[1]-1] != 0):
							maze[rand_wall[0]][rand_wall[1]-1] = .5
						if ([rand_wall[0], rand_wall[1]-1] not in walls):
							walls.append([rand_wall[0], rand_wall[1]-1])


				# Delete wall
				for wall in walls:
					if (wall[0] == rand_wall[0] and wall[1] == rand_wall[1]):
						walls.remove(wall)

				continue

		# Check if it is an upper wall
		if (rand_wall[0] != 0):
			if ((maze[rand_wall[0]-1][rand_wall[1]] == .2) and (maze[rand_wall[0]+1][rand_wall[1]] == 0)):

				s_cells = surroundingCells(rand_wall, width, height, maze)
				if (s_cells < 2):
					# Denote the new path
					maze[rand_wall[0]][rand_wall[1]] = 0

					# Mark the new walls
					# Upper cell
					if (rand_wall[0] != 0):
						if (maze[rand_wall[0]-1][rand_wall[1]] != 0):
							maze[rand_wall[0]-1][rand_wall[1]] = .5
						if ([rand_wall[0]-1, rand_wall[1]] not in walls):
							walls.append([rand_wall[0]-1, rand_wall[1]])

					# Leftmost cell
					if (rand_wall[1] != 0):
						if (maze[rand_wall[0]][rand_wall[1]-1] != 0):
							maze[rand_wall[0]][rand_wall[1]-1] = .5
						if ([rand_wall[0], rand_wall[1]-1] not in walls):
							walls.append([rand_wall[0], rand_wall[1]-1])

					# Rightmost cell
					if (rand_wall[1] != width-1):
						if (maze[rand_wall[0]][rand_wall[1]+1] != 0):
							maze[rand_wall[0]][rand_wall[1]+1] = .5
						if ([rand_wall[0], rand_wall[1]+1] not in walls):
							walls.append([rand_wall[0], rand_wall[1]+1])

				# Delete wall
				for wall in walls:
					if (wall[0] == rand_wall[0] and wall[1] == rand_wall[1]):
						walls.remove(wall)

				continue

		# Check the bottom wall
		if (rand_wall[0] != height-1):
			if ((maze[rand_wall[0]+1][rand_wall[1]] == .2) and (maze[rand_wall[0]-1][rand_wall[1]] == 0)):

				s_cells = surroundingCells(rand_wall, width, height, maze)
				if (s_cells < 2):
					# Denote the new path
					maze[rand_wall[0]][rand_wall[1]] = 0

					# Mark the new walls
					if (rand_wall[0] != height-1):
						if (maze[rand_wall[0]+1][rand_wall[1]] != 0):
							maze[rand_wall[0]+1][rand_wall[1]] = .5
						if ([rand_wall[0]+1, rand_wall[1]] not in walls):
							walls.append([rand_wall[0]+1, rand_wall[1]])
					if (rand_wall[1] != 0):
						if (maze[rand_wall[0]][rand_wall[1]-1] != 0):
							maze[rand_wall[0]][rand_wall[1]-1] = .5
						if ([rand_wall[0], rand_wall[1]-1] not in walls):
							walls.append([rand_wall[0], rand_wall[1]-1])
					if (rand_wall[1] != width-1):
						if (maze[rand_wall[0]][rand_wall[1]+1] != 0):
							maze[rand_wall[0]][rand_wall[1]+1] = .5
						if ([rand_wall[0], rand_wall[1]+1] not in walls):
							walls.append([rand_wall[0], rand_wall[1]+1])

				# Delete wall
				for wall in walls:
					if (wall[0] == rand_wall[0] and wall[1] == rand_wall[1]):
						walls.remove(wall)


				continue
		# Check the right wall
		if (rand_wall[1] != width-1):
			if ((maze[rand_wall[0]][rand_wall[1]+1] == .2) and (maze[rand_wall[0]][rand_wall[1]-1] == 0)):

				s_cells = surroundingCells(rand_wall, width, height, maze)
				if (s_cells < 2):
					# Denote the new path
					maze[rand_wall[0]][rand_wall[1]] = 0

					# Mark the new walls
					if (rand_wall[1] != width-1):
						if (maze[rand_wall[0]][rand_wall[1]+1] != 0):
							maze[rand_wall[0]][rand_wall[1]+1] = .5
						if ([rand_wall[0], rand_wall[1]+1] not in walls):
							walls.append([rand_wall[0], rand_wall[1]+1])
					if (rand_wall[0] != height-1):
						if (maze[rand_wall[0]+1][rand_wall[1]] != 0):
							maze[rand_wall[0]+1][rand_wall[1]] = .5
						if ([rand_wall[0]+1, rand_wall[1]] not in walls):
							walls.append([rand_wall[0]+1, rand_wall[1]])
					if (rand_wall[0] != 0):
						if (maze[rand_wall[0]-1][rand_wall[1]] != 0):
							maze[rand_wall[0]-1][rand_wall[1]] = .5
						if ([rand_wall[0]-1, rand_wall[1]] not in walls):
							walls.append([rand_wall[0]-1, rand_wall[1]])

				# Delete wall
				for wall in walls:
					if (wall[0] == rand_wall[0] and wall[1] == rand_wall[1]):
						walls.remove(wall)

				continue
		# Delete the wall from the list anyway
		for wall in walls:
			if (wall[0] == rand_wall[0] and wall[1] == rand_wall[1]):
				walls.remove(wall)

	# Mark the remaining unvisited cells as walls
	for i in range(0, height):
		for j in range(0, width):
			if (maze[i][j] == .2):
				maze[i][j] = .5

	# Set entrance and exit
	for i in range(0, width):
		if (maze[1][i] == 0):
			maze[0][i] = .8
			break

	for i in range(width-1, 0, -1):
		if (maze[height-2][i] == 0):
			maze[height-1][i] = 1
			break
	return maze





def canMove(eyes):
  canmove=[0,0,0,0]
  if(eyes[0][1]==0):
    canmove[0]=1
  if(eyes[2][1]==0):
    canmove[1]=1
  if(eyes[1][0]==0):
    canmove[2]=1
  if(eyes[1][2]==0):
    canmove[3]=1
  return canmove



def OnehotEncodeMap(map):
  Encoded_Map=[]
  for y in range(len(map)):
    xholder=[]
    for x in range(len(map[0])):
      if(map[y][x]==1):
        xholder.append([1, 0, 0, 0])
      elif(map[y][x]==.5):
        xholder.append([0, 1, 0, 0])
      elif(map[y][x]==0):
        xholder.append([0, 0, 1, 0])
      elif(map[y][x]==.8):
        xholder.append([0, 0, 0, 1])
    Encoded_Map.append(xholder)
  return Encoded_Map



def getscore(Maze):
  MazeSolved =[]
  for y in range(len(Maze)):
    MazeShold=[]
    for x in range(len(Maze[0])):
      if(Maze[y][x] == .5 or y==len(Maze)-1):
        MazeShold.append(2)
      elif(Maze[y][x] == .8):
        MazeShold.append(1)
      else:
        MazeShold.append(0)
    MazeSolved.append(MazeShold)
  for i in range(20):
    for y in range(len(Maze)):
      for x in range(len(Maze[0])):
        if(MazeSolved[y][x] == 0):
          if(MazeSolved[y-1][x] <= 1):
            MazeSolved[y][x] += MazeSolved[y-1][x]*.95
          if(MazeSolved[y+1][x] <= 1):
            MazeSolved[y][x] += MazeSolved[y+1][x]*.95
          if(MazeSolved[y][x-1] <= 1):
            MazeSolved[y][x] += MazeSolved[y][x-1]*.95
          if(MazeSolved[y][x+1] <= 1):
            MazeSolved[y][x] += MazeSolved[y][x+1]*.95
  for y in range(len(Maze)):
    for x in range(len(Maze[0])):
      if(Maze[y][x] == 1):
        Ppos = [x,y]
  if (Ppos[1] == len(Maze)-1):
    return 0
  elif (Ppos[1] == 0):
    return 1
  else:
    return MazeSolved[Ppos[1]][Ppos[0]]

def IsMazeDone(Maze):
  MazeSolved =[]
  for x in range(len(Maze)):
    if(Maze[0][x] == 1):
      return True
  return False

def MoveMaze(maze, direction):
  mazec=maze.copy()
  for y in range(len(maze)):
    for x in range(len(maze[0])):
      if(maze[y][x] == 1):
        Ppos = [x,y]
  if(direction=="u"):
   if((Ppos[1] >0) and ((maze[Ppos[1]-1][Ppos[0]]==0) or (maze[Ppos[1]-1][Ppos[0]]==.8))):
      mazec[Ppos[1]-1][Ppos[0]] = 1
      mazec[Ppos[1]][Ppos[0]] = 0
   else:
     return mazec, "Invalid Move"
  if(direction=="d"):
   if((Ppos[1] < len(maze)-1) and (maze[Ppos[1]+1][Ppos[0]]==0 or maze[Ppos[1]+1][Ppos[0]]==.8)):
      mazec[Ppos[1]+1][Ppos[0]] = 1
      mazec[Ppos[1]][Ppos[0]] = 0
   else:
     return mazec, "Invalid Move"
  if(direction=="l"):
   if((Ppos[0] > 0) and (maze[Ppos[1]][Ppos[0]-1]==0 or maze[Ppos[1]][Ppos[0]-1]==.8)):
      mazec[Ppos[1]][Ppos[0]-1] = 1
      mazec[Ppos[1]][Ppos[0]] = 0
   else:
     return mazec, "Invalid Move"
  if(direction=="r"):
   if((Ppos[0] < len(maze)-1) and (maze[Ppos[1]][Ppos[0]+1]==0 or maze[Ppos[1]][Ppos[0]+1]==.8)):
      mazec[Ppos[1]][Ppos[0]+1] = 1
      mazec[Ppos[1]][Ppos[0]] = 0
   else:
     return mazec, "Invalid Move"
  return mazec, "Successful Move"

def AisetMazeVision(Maze, VisionX=AI_EYES_X, VisionY=AI_EYES_Y):
  for y in range(len(Maze)):
    for x in range(len(Maze[0])):
      if(Maze[y][x] == 1):
        Ppos = [x,y]
  Aieye = []
  for y in range(VisionY):
    eyeHold = []
    for x in range(VisionX):
      if(((Ppos[1]+y-(VisionY-1)/2>=0)and (Ppos[1]+y-(VisionY-1)/2<len(Maze))) and ((Ppos[0]+x-(VisionX-1)/2>=0) and (Ppos[0]+x-(VisionX-1)/2<len(Maze)))):
        eyeHold.append(Maze[Ppos[1]+y-int((VisionY-1)/2)][Ppos[0]+x-int((VisionX-1)/2)])
      else:
        eyeHold.append(.5)
    Aieye.append(eyeHold)
  return Aieye



def getbestMemory(callback, memories):
  pick = 0
  pickScore=0
  currentScore=0
  for mem in range(len(memories)):
    Error = 0
    for d1 in range(len(callback)):
      Error += math.pow(memories[mem][2][d1],2)
    currentScore = (1/(Error+.01)) * memories[mem][1][0] * memories[mem][1][1]
    if(pickScore < currentScore):
      pickScore = currentScore
      pick = mem
  return pick

def getmultiplebestMemories(callback, memories, amount=START_MEM_INPUTS):
  memoriesCopy = memories.copy()
  pickedMemories = []
  for i in range(amount):
    memHolder = []
    pick = getbestMemory(callback, memoriesCopy)
    for x in range(len(memoriesCopy[pick][3])):
      memHolder.append(memoriesCopy[pick][3][x])
    memoriesCopy.pop(pick)
    pickedMemories.append(memHolder)
  return pickedMemories

def MakeBaseMemories(Info):
  Memory0 = []
  for i in range(Info[0]):
    Memory0.append([[0], [.0001, 1, 0], [0]*Info[1], [0]*Info[2]])
  return Memory0

DNASIZE = [520, 256, 256, 256, 256, 256, 186]

def MakeStartingAI(DnaSize, Max_Connections, Full_connection=False):
  Dna = []
  for N_Depth in range(len(DnaSize)-1):
    Layer_holder = []
    for Layer_size in range(DnaSize[N_Depth]):
      Connention_holder=[]
      if(Full_connection == True):
        for Connection in range(DnaSize[N_Depth+1]):
          Neron_output = []
          Neron_output.append(Connection)
          Neron_output.append([0, 0])
          Connention_holder.append(Neron_output)
        Layer_holder.append(Connention_holder)
      else:
        for Connection in range(Max_Connections):
          Neron_output = []
          Neron_output.append(random.randint(-1, DnaSize[N_Depth+1]-1))
          if (Neron_output[0] != -1):
            Neron_output.append([0, 0])
          Connention_holder.append(Neron_output)
        Layer_holder.append(Connention_holder)
    Dna.append(Layer_holder)
  Finalrow = []
  for final_output in range(DnaSize[len(DnaSize)-1]):
    Finalrow.append(final_output)
  Dna.append(Finalrow)
  return Dna



def DnaMutator(Dna_old, Disconnect_rate, Connect_rate, WB_rate, WC, BC):
  Dna = Dna_old
  for N_Depth in range(len(Dna_old)-1):
    Current_layer = Dna_old[N_Depth]
    for Layer_size in range(len(Current_layer)):
      Current_Conections = Current_layer[Layer_size]
      for Connection in range(len(Current_Conections)):
        if (Current_Conections[Connection][0] == -1):
          if(random.randint(0, 9999) < Connect_rate*100):#Persision down to .01%
            normal_away = np.random.default_rng().normal(size=5)[0]
            Dna[N_Depth][Layer_size][Connection] = [random.randint(0, len(Dna_old[N_Depth+1])-1),[WC*normal_away, BC*normal_away]]
        else:
          if(random.randint(0, 9999) < Disconnect_rate*100):
            Dna[N_Depth][Layer_size][Connection] = [-1]
          else:
            if(random.randint(0, 9999) < WB_rate*100):
              normal_away = np.random.default_rng().normal(size=5)[0]
              Dna[N_Depth][Layer_size][Connection][1][0] += WC * normal_away
              normal_away = np.random.default_rng().normal(size=5)[0]
              Dna[N_Depth][Layer_size][Connection][1][1] += BC * normal_away
              if(Dna[N_Depth][Layer_size][Connection][1][1] < -.2):
                Dna[N_Depth][Layer_size][Connection][1][1] = -.2
              if(Dna[N_Depth][Layer_size][Connection][1][1] > .2):
                Dna[N_Depth][Layer_size][Connection][1][1] = .2
  return Dna

def DnaMutatorSpeed(Dna_old, Disconnect_rate, Connect_rate, WB_rate, WC, BC):
  Dna = Dna_old
  NodeAmount = len(Dna_old[0][0])
  for N_Depth in range(len(Dna_old)-2):
    Current_layer = Dna_old[N_Depth]
    Change=[]
    for Layer_size in range(int(len(Current_layer)*(WC))):
      Change.append(random.randint(0,len(Current_layer)-1))
      for Connection in range(len(Change)):
        ChosenNode = random.randint(0,NodeAmount-1)
        if (Dna[N_Depth][Change[Connection]][ChosenNode][0] == -1):
          normal_away = np.random.default_rng().normal(size=5)[0]
          Dna[N_Depth][Change[Connection]][ChosenNode] = [random.randint(0, len(Dna_old[N_Depth+1])-1),[WC*normal_away, BC*normal_away]]
        else:
          normal_away = np.random.default_rng().normal(size=5)[0]
          Dna[N_Depth][Change[Connection]][ChosenNode][1][0] += WC * normal_away
          normal_away = np.random.default_rng().normal(size=5)[0]
          Dna[N_Depth][Change[Connection]][ChosenNode][1][1] += BC * normal_away
          if(Dna[N_Depth][Change[Connection]][ChosenNode][1][1] < 0):
            Dna[N_Depth][Change[Connection]][ChosenNode][1][1] = 0
          if(Dna[N_Depth][Change[Connection]][ChosenNode][1][0] < 0):
            Dna[N_Depth][Change[Connection]][ChosenNode][1][0] = 0
  return Dna

DNA = MakeStartingAI(DNASIZE, 100)
DNA = DnaMutator(DNA, .5, 100, .5, .1, .1)

def testing(Dna, object):
  if(len(Dna[0]) == len(object)):
    Output_row = []
    for N_Depth in range(len(Dna)):
      Current_layer = []
      for Layer_size in range(len(Dna[N_Depth])):
        if (N_Depth == 0):
          Current_layer.append(object[Layer_size])
        else:
          Current_layer.append(0)
      Output_row.append(Current_layer)
    for N_Depth in range(len(Dna)-1):
      Current_layer = Dna[N_Depth]
      for Layer_size in range(len(Current_layer)):
        Current_Conections = Current_layer[Layer_size]
        for Connection in range(len(Current_Conections)):
          if (Current_Conections[Connection][0] != -1):
            Wieght_Bias = Current_Conections[Connection][1]
            Next_add = (Output_row[N_Depth][Layer_size]*Wieght_Bias[0] + Wieght_Bias[1])
            if(Next_add > 0):
              Output_row[N_Depth+1][Current_Conections[Connection][0]] += Next_add
    for lastrowsig in range(len(Output_row[len(Output_row)-1])):
      Output_row[len(Output_row)-1][lastrowsig] = (Output_row[len(Output_row)-1][lastrowsig])
    return Output_row
  else:
    return "Incopatible types"





def AiOutputDecrypter(Outputs, empty_outputs, Outinfo, canmove,Print=False):
  direction = -1
  randomp = 0
  Total_added = 0
  desisions = []
  if(Print):
    print(Outputs)
  for i in range(len(Outputs)):
    Outputs[i]=Outputs[i]-empty_outputs[i]
  if(Print):
    print(Outputs)
  for i in range(4):
    if(canmove[i]==1):
      desisions.append(Outputs[Total_added+i])
    else:
      desisions.append(0)
  desisions=proportianalfrequency(desisions)
  pickedvalue = random.randint(1,100)
  if(Print):
    print(desisions)
  if(Print):
    print(pickedvalue)
  for i in range(4):
    if(pickedvalue<desisions[Total_added]*100):
      if(direction==-1):
        direction=Total_added
    else:
      pickedvalue-=desisions[Total_added]*100
    Total_added+=1
  if(direction==0):
    direction = "u"
  if(direction==1):
    direction = "d"
  if(direction==2):
    direction = "l"
  if(direction==3):
    direction = "r"
  if(Print):
    print(direction)
  Memory_Reinput = []
  callback = []
  newMemory = []
  for y in range(Outinfo[0]):
    Memory_Reinput.append(Outputs[Total_added])
    Total_added+=1
  Memory_Reinput = proportianalfrequency(Memory_Reinput)
  for i in range(Outinfo[1]):
    callback.append(Outputs[Total_added])
    Total_added+=1
  callback=proportianalfrequency(callback)
  for i in range(Outinfo[2]):
    newMemory.append(Outputs[Total_added])
    Total_added+=1
  newMemory=proportianalfrequency(newMemory)
  ImDecay = [0, 0]
  #ImDecay[0] = sigmoid(Outputs[Total_added])
  ImDecay[0] = .1
  Total_added+=1
  if(ImDecay[0]==0):
    ImDecay[0]=.1
  #ImDecay[1] = sigmoid(Outputs[Total_added])
  ImDecay[1] = .1
  return [direction, Memory_Reinput, callback, newMemory, ImDecay]

#outinfo = [reinput, callback, memlength]

def defalt_Outputs(Dna, memSize, memInputs, reinputSize, callback):
  Maze = MakeMaze(20,20)
  Ai_Eyes = [[[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]],
            [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]],
            [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]],
            [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]],
            [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]]]
  Memories =getmultiplebestMemories([0], MakeBaseMemories([memInputs,1,memSize]),memInputs)
  AIInputs=GetInputs(Ai_Eyes, Memories, [0]*reinputSize)
  hold = testing(Dna, AIInputs)
  output = hold[len(hold)-1]
  return output

def RunNetwork(callback, re_Input, Maze, Memories, Dna, memInAmount, randomness, Print=False):
  best_Memories = getmultiplebestMemories(callback, Memories, memInAmount)
  if(Print):
    print(best_Memories)
  Ai_Eyes = AisetMazeVision(Maze)
  can_move = canMove(Ai_Eyes)
  Ai_encoded_eyes = OnehotEncodeMap(Ai_Eyes)
  AIInputs=GetInputs(Ai_encoded_eyes, best_Memories,re_Input)
  hold = testing(Dna, AIInputs)
  AI_Outputs = hold[len(hold)-1]
  defaltOutputs = defalt_Outputs(Dna, len(Memories[0][3]), memInAmount, len(re_Input), callback)
  Outputholder = AiOutputDecrypter(AI_Outputs, defaltOutputs, [len(re_Input), len(callback), len(Memories[0][3]), randomness], can_move, Print)
  Memories.append([[0], [Outputholder[4][0], 1, Outputholder[4][1]], Outputholder[2], Outputholder[3]])
  Maze, Successmove = MoveMaze(Maze, Outputholder[0])
  return Outputholder, Successmove

def DecayMemories(memories):
  memoriesc = memories.copy()
  i=0
  while(i < len(memoriesc)):
    memoriesc[i][1][1] -= memoriesc[i][1][2]
    if(memoriesc[i][1][1] <= 0):
      memoriesc.pop(i)
    else:
      i += 1
  return memoriesc

#[Dna, mutatelevel, memories, maps]

def MutateAIlistup(amount, Dnalist, memory, specialInfo, MazeSize=20):
  DnalistC = copy.deepcopy(Dnalist)
  Mazelist = []
  for i in range(TRIALS):
    Mazelist.append(copy.deepcopy(MakeMaze(MazeSize,MazeSize)))
  Dnal = []
  Mazel = []
  Memoryl = []
  SpecialInfo = []
  AiMemoryVisl = []
  Callbackl = []
  dholder = Dnalist[0].copy()
  for i in range(len(Dnalist)):
    for x in range(amount):
      SpecialInfo.append(copy.deepcopy(specialInfo[i]))
      if(x==0):
        Dnal.append(DnalistC[i])
      else:
        DnaMutated = copy.deepcopy(DnalistC[i])
        oldinfo = copy.deepcopy(specialInfo[i])
        if(random.randint(1,1000)>960):
          print("SizeIncrease")
          print(len(SpecialInfo))
          DnaMutated = WidenMutation(DnaMutated)
          print(len(DnaMutated[1]))
        elif(random.randint(1,1000)>990):
          print("ConectionIncrease")
          print(len(SpecialInfo))
          DnaMutated = AddConnection(DnaMutated)
          SpecialInfo[len(SpecialInfo)-1][5]+=1
          oldinfo[5]+=1
        elif(random.randint(1,1000)>990):
          print("Callbacks")
          print(len(SpecialInfo))
          if(random.randint(1,2)==1):
            SpecialInfo[len(SpecialInfo)-1][1]+=1
            DnaMutated = changeDNAorentation(DnaMutated, oldinfo, SpecialInfo[len(SpecialInfo)-1])
            oldinfo[1]+=1
            print(len(DnaMutated[4]))
          else:
            if(SpecialInfo[i][1]>1):
              print(len(DnaMutated[4]))
              print(oldinfo)
              SpecialInfo[len(SpecialInfo)-1][1]-=1
              DnaMutated = changeDNAorentation(DnaMutated, oldinfo, SpecialInfo[len(SpecialInfo)-1])
              oldinfo[1]-=1
          print(oldinfo)
        elif(random.randint(1,1000)>975):
          print("MemSize")
          if(random.randint(1,1)==1):
            SpecialInfo[len(SpecialInfo)-1][2]+=1
            DnaMutated = changeDNAorentation(DnaMutated, oldinfo, SpecialInfo[len(SpecialInfo)-1])
            oldinfo[2]+=1
          print(oldinfo)
        elif(random.randint(1,1000)>995):
          print("Mem_amount")
          if(random.randint(1,1)==1):
            SpecialInfo[len(SpecialInfo)-1][3]+=1
            DnaMutated = changeDNAorentation(DnaMutated, oldinfo, SpecialInfo[len(SpecialInfo)-1])
            oldinfo[3]+=1
          else:
            SpecialInfo[len(SpecialInfo)-1][3]-=1
            DnaMutated = changeDNAorentation(DnaMutated, oldinfo, SpecialInfo[len(SpecialInfo)-1])
            oldinfo[3]-=1
          print(len(DnaMutated[0]))
          print(oldinfo)
        if(random.randint(1,1000)>990):
          print("Reinputsize")
          if(random.randint(1,1)==1):
            SpecialInfo[len(SpecialInfo)-1][4]+=1
            print(len(DnaMutated[0]))
            DnaMutated = changeDNAorentation(DnaMutated, oldinfo, SpecialInfo[len(SpecialInfo)-1])
            print(len(DnaMutated[0]))
            oldinfo[4]+=1
          print(oldinfo)
        if(random.randint(1,1000)>500):
          if(random.randint(1,2)==1):
            SpecialInfo[len(SpecialInfo)-1][6]+=1
          elif(SpecialInfo[len(SpecialInfo)-1][6]>1):
            SpecialInfo[len(SpecialInfo)-1][6]-=1
        if (random.randint(1,1000)>950):
          Mutant_Dna_Holder = DnaMutator(DnaMutated, 0, 100, specialInfo[i][0][0]*3, specialInfo[i][0][1]*20, specialInfo[i][0][2])
        else:
          Mutant_Dna_Holder = DnaMutator(DnaMutated, 0, 100, specialInfo[i][0][0]*2, specialInfo[i][0][1]*5, specialInfo[i][0][2]/50)
        SpecialInfo[len(SpecialInfo)-1][0]=([specialInfo[i][0][0]+.01*random.randint(-10, 10), specialInfo[i][0][1]+.01*random.randint(-10, 10), specialInfo[i][0][2]+.01*random.randint(-10, 10)])
        Dnal.append(Mutant_Dna_Holder)
      Mazel.append(Mazelist)
      Memoryl.append(copy.deepcopy(MakeBaseMemories([SpecialInfo[i*amount+x][3],SpecialInfo[i*amount+x][1],SpecialInfo[i*amount+x][2]]))) # changed
      Callbackl.append([0]*SpecialInfo[i*amount+x][1])
  print(len(SpecialInfo))
  print(len(Dnal))
  return [Dnal, Mazel, Memoryl, Callbackl, SpecialInfo]

#specialinfo=[[.3, .2, .2]],[START_MEMCALLB_SIZE],[START_MEM_SIZE],[START_MEM_INPUTS],[START_REINPUT_SIZE],["Connections"],["randomnes"]

#Special_info=[Callbacksize, memorysize, Reinputlevel ,Mutationlevel]

def WidenMutation(Dna_old):
  DNA_WIDEND = copy.deepcopy(Dna_old)
  for N_Depth in range(len(Dna_old)-2):
    Current_layer = Dna_old[N_Depth+1]
    DNA_WIDEND[N_Depth+1].append([[-1]]*len(Current_layer[0]))
  return DNA_WIDEND

def AddConnection(Dna_old):
  DNA_Conected = copy.deepcopy(Dna_old)
  for N_Depth in range(len(Dna_old)-1):
    Current_layer = Dna_old[N_Depth]
    for Layer_size in range(len(Current_layer)):
      DNA_Conected[N_Depth][Layer_size].append([-1])
  return DNA_Conected

def changeDNAorentation(Dna_old, previousInfo, NewInfo):
  Changed_DNA = copy.deepcopy(Dna_old)
  if(previousInfo[1]<NewInfo[1]):
    ChangedPos=4+previousInfo[4]
    Current_layer = Dna_old[len(Dna_old)-2]
    for Layer_size in range(len(Dna_old[len(Dna_old)-2])):
     Current_Conections = Current_layer[Layer_size]
     for Connection in range(len(Current_Conections)):
        if(Current_Conections[Connection][0]>=ChangedPos):
          Changed_DNA[len(Dna_old)-2][Layer_size][Connection][0] +=1
    Changed_DNA[len(Dna_old)-1].append(len(Dna_old[len(Dna_old)-1]))
  if(previousInfo[1]>NewInfo[1]):
    ChangedPos=4+previousInfo[4]
    Current_layer = Dna_old[len(Dna_old)-2]
    for Layer_size in range(len(Dna_old[len(Dna_old)-2])):
     Current_Conections = Current_layer[Layer_size]
     for Connection in range(len(Current_Conections)):
        if(Current_Conections[Connection][0]>ChangedPos):
          Changed_DNA[len(Dna_old)-2][Layer_size][Connection][0] -=1
        elif(Current_Conections[Connection][0]==ChangedPos):
          Changed_DNA[len(Dna_old)-2][Layer_size][Connection] = [-1]
    Changed_DNA[len(Dna_old)-1].pop(len(Dna_old[len(Dna_old)-1])-1)
  if(previousInfo[2]<NewInfo[2]):
    for i in range(previousInfo[3]):
      Changed_DNA[0].insert(AI_EYES_X*AI_EYES_Y*4+NewInfo[2]*i,[[-1]*previousInfo[5]])
    ChangePos = 4+previousInfo[4]+previousInfo[1]
    Current_layer = Dna_old[len(Dna_old)-2]
    for Layer_size in range(len(Dna_old[len(Dna_old)-2])):
     Current_Conections = Current_layer[Layer_size]
     for Connection in range(len(Current_Conections)):
        if(Current_Conections[Connection][0]>=ChangePos):
          Changed_DNA[len(Dna_old)-2][Layer_size][Connection][0] += 1
    Changed_DNA[len(Dna_old)-1].append(len(Dna_old[len(Dna_old)-1]))
  if(previousInfo[3]<NewInfo[3]):
    ChangePos = 4+previousInfo[4]+previousInfo[1]+previousInfo[2]*previousInfo[3]
    for i in range(previousInfo[2]):
      Changed_DNA[0].insert(ChangePos+i, [[-1]*previousInfo[5]])
  if(previousInfo[4]<NewInfo[4]):
    ChangePos = 4
    Changed_DNA[0].insert(AI_EYES_X*AI_EYES_Y*4+NewInfo[2]*NewInfo[3],[[-1]*previousInfo[5]])
    Current_layer = Dna_old[len(Dna_old)-2]
    for Layer_size in range(len(Dna_old[len(Dna_old)-2])):
     Current_Conections = Current_layer[Layer_size]
     for Connection in range(len(Current_Conections)):
        if(Current_Conections[Connection][0]>=ChangePos):
          Changed_DNA[len(Dna_old)-2][Layer_size][Connection][0] += 1
    Changed_DNA[len(Dna_old)-1].append(len(Dna_old[len(Dna_old)-1]))
  return Changed_DNA



Maze = MakeMaze(20,20)
DNA = MakeStartingAI(STARTING_DNABASE, STARTING_CONNECTIONS)
DNA = DnaMutator(DNA, 1, 100, 100, .2, .2)
Memories = MakeBaseMemories([START_MEM_INPUTS,START_MEMCALLB_SIZE,START_MEM_SIZE])
RunNetwork([0], [0,0], Maze, copy.deepcopy(Memories), DNA, START_MEM_INPUTS, 10, Print=False)

#DNAC= changeDNAorentation(DNA, [0,1,2,2,4,8], [0,1,3,2,4,8])
#Memories = MakeBaseMemories([2,1,3])
#RunNetwork([0], [0,0,0], Maze, copy.deepcopy(Memories), DNAC, 2, Print=False)

def gettopAI(Datascorelist, Dnalist, mutatelevel, amount=AMOUNT_PICKED):
  DatascorelCopy = Datascorelist.copy()
  DnalCopy = Dnalist.copy()
  Mutatelist = mutatelevel.copy()
  Mutatebest = []
  pickedScores = []
  for i in range(amount):
    pick = 0
    for x in range(len(DatascorelCopy)):
      if(DatascorelCopy[pick]<DatascorelCopy[x]):
        pick=x
    pickedScores.append(DnalCopy[pick])
    Mutatebest.append(Mutatelist[pick])
    Mutatelist.pop(pick)
    DatascorelCopy.pop(pick)
    DnalCopy.pop(pick)
  return [pickedScores, Mutatebest]

def testList(Dnal, Mazel, Memoryl, Callbackl, SpecialInfo, Attempts=30):
  scorel = []
  Cmpp = 0
  for d in range(len(Dnal)):
    if(100*d/len(Dnal)+1>=Cmpp+10):
      Cmpp += 10
      print("Testing:" + str(Cmpp) + "%")
    score = 0
    Memories = copy.deepcopy(MakeBaseMemories([SpecialInfo[d][3],SpecialInfo[d][1],SpecialInfo[d][2]]))
    Dna = Dnal[d]
    for m in range(len(Mazel[0])):
      Maze = copy.deepcopy(Mazel[d][m])
      Ai_Eyes = copy.deepcopy(AisetMazeVision(Maze))
      Moveditector = ""
      if (((d==0) and (m==100)) and (0==0)):
        plt.imshow(Maze, interpolation='none')
        plt.show()
      G1Outputholder, Moveditector = RunNetwork([0]*len(Callbackl[d]), [0]*SpecialInfo[d][4], Maze, Memories, Dna, SpecialInfo[d][3], SpecialInfo[d][6])
      Isdone=False
      Do_Print = False
      for i in range(Attempts):
        if(Isdone==False):
          if((Moveditector == "Successful Move") or (0==0)):
            if (((d==0) and (m==0)) and ((Moveditector == "Successful Move"))):
              Do_Print = True
              plt.imshow(Maze, interpolation='none')
              plt.show()
            if (((d==0) and (m==0)) and (0==1)):
              Do_Print = False
              plt.imshow(AisetMazeVision(Maze), interpolation='none')
              plt.show()
            G1Outputholder, Moveditector = RunNetwork(G1Outputholder[2], G1Outputholder[1], Maze, Memories, Dna, SpecialInfo[d][3], SpecialInfo[d][6], Do_Print)
            Memories = copy.deepcopy(DecayMemories(Memories))
            Isdone= IsMazeDone(Maze)
      score += getscore(Maze)
    scorel.append(score)
  return scorel

def DnaToDataFrame(Dna):
  Datalist = []
  for N_Depth in range(len(Dna)-1):
    for Layer_size in range(len(Dna[N_Depth])):
      Datalist.append(Dna[N_Depth][Layer_size])
  DataFrame = pd.DataFrame(Datalist)
  return DataFrame

def DataFrameToDna(Data, Connection_rate=DNASIZE, DnaSize=DNASIZE, InString=True):
  Dna = []
  print(DnaSize)
  for N_Depth in range(len(DnaSize)-1):
    Layer_holder = []
    for Layer_size in range(DnaSize[N_Depth]):
      Connection_holder=[]
      for Connection in range(Connection_rate[N_Depth+1]):
        if(InString==True):
          Connection_holder.append(ast.literal_eval(Data[str(Connection)][Layer_size+getprevios(DnaSize, N_Depth)]))
        else:
          Connection_holder.append(Data[Connection][Layer_size+getprevios(DnaSize, N_Depth)])
      Layer_holder.append(Connection_holder)
    Dna.append(Layer_holder)
  Finalrow = []
  for final_output in range(DnaSize[len(DnaSize)-1]):
    Finalrow.append(final_output)
  Dna.append(Finalrow)
  return Dna

#START_MEMCALLB_SIZE = 1 #detail in memory reteval
#START_MEM_SIZE = 4 #detail in memory
#START_MEM_INPUTS

Maze = MakeMaze(20,20)

len(Memories)



DNA = MakeStartingAI(STARTING_DNABASE, STARTING_CONNECTIONS, True)
DNA = DnaMutator(DNA, 0, 100, 10, 2, .01)
SpecialInfo =[[[1, 1, 1],START_MEMCALLB_SIZE, START_MEM_SIZE, START_MEM_INPUTS, START_REINPUT_SIZE, STARTING_CONNECTIONS, .5]]
print(SpecialInfo)
Memories = MakeBaseMemories([SpecialInfo[0][3],SpecialInfo[0][1],SpecialInfo[0][2]])
Solverhold =MutateAIlistup(AMOUNT_PICKED, [DNA], Memories, SpecialInfo)
Dnalscores = testList(Solverhold[0],Solverhold[1],Solverhold[2],Solverhold[3],Solverhold[4],1)

def getInfoaverages(info):
  infototals = [0,0,0,0,0,0]
  mutatetotals=[0,0,0]
  for i in range(len(info)):
    for x in range(len(info[0])-1):
      infototals[x]+=info[i][x+1]/len(info)
  for i in range(len(info)):
    for x in range(3):
      mutatetotals[x]+=info[i][0][x]/len(info)
  infototals.insert(0,mutatetotals)
  return infototals



Overal_avperformance = []
Map_Size = 12
performance=.05
Infoaverages = []
for i in range(10000):
  print("Gen:"+str(i+1))
  TopAi = gettopAI(Dnalscores, Solverhold[0], Solverhold[4])
  Solverhold = MutateAIlistup(DESENDENT_RATE, TopAi[0], Memories, TopAi[1], Map_Size)
  Dnalscores = testList(Solverhold[0],Solverhold[1],Solverhold[2],Solverhold[3],Solverhold[4],5*Map_Size)
  top = 0
  for t in range(len(Dnalscores)):
    if(Dnalscores[0] < Dnalscores[t]):
      top=t
  print(Dnalscores)
  performance=0
  for i in range(len(Dnalscores)):
    performance+=Dnalscores[i]
  print(performance/(POPULATION*TRIALS))
  Overal_avperformance.append(performance/(POPULATION*TRIALS))
  if((performance/(POPULATION*TRIALS) > .9) or (i%25==24)):
    SaveDna, SaveInfo = gettopAI(Dnalscores, Solverhold[0], Solverhold[4])[0][0], gettopAI(Dnalscores, Solverhold[0], Solverhold[4])[1][0]
    DnaToDataFrame(SaveDna).to_csv(("Gen:" + str(i) +  ":" + str(int(Overal_avperformance[len(Overal_avperformance)-1]*100)) + "%TopAI"), index=False)
    SaveInfo = pd.DataFrame([SaveInfo[1],SaveInfo[2],SaveInfo[3],SaveInfo[4],SaveInfo[5]])
    SaveInfo.to_csv("Gen:" + str(i) +  ":" + str(int(Overal_avperformance[len(Overal_avperformance)-1]*100)) + "AIinfo")
    if(performance/(POPULATION*TRIALS) > .9):
      Map_Size=int((Map_Size+1)*1.1)
    print(Map_Size)
  Infoaverages.append(getInfoaverages(Solverhold[4])[6])
  print(getInfoaverages(Solverhold[4]))
  #plt.plot(Infoaverages)
  #plt.title("Randomness")
  #plt.show()
  og_scores = []
  for i in range(int(len(Dnalscores)/2)):
    og_scores.append(Dnalscores[2*i])
  plt.plot(og_scores)
  plt.title("OGScores")
  plt.show()
  plt.plot(Dnalscores)
  plt.title("Scores")
  plt.show()
  plt.plot(Overal_avperformance)
  plt.title("Overalpreformance")
  plt.show()
  time = []